// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::execution_providers::ExecutionProviderBase;
use crate::api::memory::*;
use crate::api::session::*;
use crate::api::tensor::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = -705982521;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__memory__MemoryInfo_allocation_device_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MemoryInfo_allocation_device",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::memory::MemoryInfo::allocation_device(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__memory__MemoryInfo_allocator_type_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MemoryInfo_allocator_type",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::memory::MemoryInfo::allocator_type(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__memory__MemoryInfo_device_id_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MemoryInfo_device_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::memory::MemoryInfo::device_id(
                    &*api_that_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__memory__MemoryInfo_device_type_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MemoryInfo_device_type",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::memory::MemoryInfo::device_type(
                    &*api_that_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__memory__MemoryInfo_is_cpu_accessible_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MemoryInfo_is_cpu_accessible",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::memory::MemoryInfo::is_cpu_accessible(&*api_that_guard),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__memory__MemoryInfo_memory_type_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "MemoryInfo_memory_type",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::memory::MemoryInfo::memory_type(
                    &*api_that_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__session__SessionImpl_builder_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SessionImpl_builder",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(crate::api::session::SessionImpl::builder())?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__session__SessionImpl_inputs_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SessionImpl_inputs",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::session::SessionImpl::inputs(
                    &*api_that_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__session__SessionImpl_outputs_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SessionImpl_outputs",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::session::SessionImpl::outputs(
                    &*api_that_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__session__SessionImpl_run_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "SessionImpl_run",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>,
            >>::sse_decode(&mut deserializer);
            let api_input_values =
                <std::collections::HashMap<String, TensorImpl>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let mut api_that_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_that, 0, true,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                                _ => unreachable!(),
                            }
                        }
                        let mut api_that_guard = api_that_guard.unwrap();
                        let output_ok = crate::api::session::SessionImpl::run(
                            &mut *api_that_guard,
                            api_input_values,
                        )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_clone_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_clone",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::tensor::TensorImpl::clone(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_dtype_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_dtype",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::tensor::TensorImpl::dtype(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_free_bool_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_free_bool_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_arr = <crate::api::tensor::ArrayPointer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::tensor::TensorImpl::free_bool_pointer(api_arr);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_free_f32_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_free_f32_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_arr = <crate::api::tensor::ArrayPointer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::tensor::TensorImpl::free_f32_pointer(api_arr);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_free_f64_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_free_f64_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_arr = <crate::api::tensor::ArrayPointer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::tensor::TensorImpl::free_f64_pointer(api_arr);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_free_i16_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_free_i16_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_arr = <crate::api::tensor::ArrayPointer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::tensor::TensorImpl::free_i16_pointer(api_arr);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_free_i32_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_free_i32_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_arr = <crate::api::tensor::ArrayPointer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::tensor::TensorImpl::free_i32_pointer(api_arr);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_free_i64_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_free_i64_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_arr = <crate::api::tensor::ArrayPointer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::tensor::TensorImpl::free_i64_pointer(api_arr);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_free_i8_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_free_i8_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_arr = <crate::api::tensor::ArrayPointer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::tensor::TensorImpl::free_i8_pointer(api_arr);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_free_string_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_free_string_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_arr = <crate::api::tensor::ArrayPointer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::tensor::TensorImpl::free_string_pointer(api_arr);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_free_u16_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_free_u16_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_arr = <crate::api::tensor::ArrayPointer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::tensor::TensorImpl::free_u16_pointer(api_arr);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_free_u32_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_free_u32_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_arr = <crate::api::tensor::ArrayPointer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::tensor::TensorImpl::free_u32_pointer(api_arr);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_free_u64_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_free_u64_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_arr = <crate::api::tensor::ArrayPointer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::tensor::TensorImpl::free_u64_pointer(api_arr);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_free_u8_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_free_u8_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_arr = <crate::api::tensor::ArrayPointer>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::tensor::TensorImpl::free_u8_pointer(api_arr);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_from_array_bool_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_from_array_bool",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_shape = <Option<Vec<i64>>>::sse_decode(&mut deserializer);
            let api_data = <Vec<bool>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::tensor::TensorImpl::from_array_bool(api_shape, api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_from_array_f32_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_from_array_f32",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_shape = <Option<Vec<i64>>>::sse_decode(&mut deserializer);
            let api_data = <Vec<f32>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::tensor::TensorImpl::from_array_f32(api_shape, api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_from_array_f64_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_from_array_f64",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_shape = <Option<Vec<i64>>>::sse_decode(&mut deserializer);
            let api_data = <Vec<f64>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::tensor::TensorImpl::from_array_f64(api_shape, api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_from_array_i16_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_from_array_i16",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_shape = <Option<Vec<i64>>>::sse_decode(&mut deserializer);
            let api_data = <Vec<i16>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::tensor::TensorImpl::from_array_i16(api_shape, api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_from_array_i32_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_from_array_i32",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_shape = <Option<Vec<i64>>>::sse_decode(&mut deserializer);
            let api_data = <Vec<i32>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::tensor::TensorImpl::from_array_i32(api_shape, api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_from_array_i64_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_from_array_i64",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_shape = <Option<Vec<i64>>>::sse_decode(&mut deserializer);
            let api_data = <Vec<i64>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::tensor::TensorImpl::from_array_i64(api_shape, api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_from_array_i8_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_from_array_i8",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_shape = <Option<Vec<i64>>>::sse_decode(&mut deserializer);
            let api_data = <Vec<i8>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::tensor::TensorImpl::from_array_i8(api_shape, api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_from_array_string_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_from_array_string",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_shape = <Option<Vec<i64>>>::sse_decode(&mut deserializer);
            let api_data = <Vec<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::tensor::TensorImpl::from_array_string(api_shape, api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_from_array_u16_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_from_array_u16",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_shape = <Option<Vec<i64>>>::sse_decode(&mut deserializer);
            let api_data = <Vec<u16>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::tensor::TensorImpl::from_array_u16(api_shape, api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_from_array_u32_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_from_array_u32",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_shape = <Option<Vec<i64>>>::sse_decode(&mut deserializer);
            let api_data = <Vec<u32>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::tensor::TensorImpl::from_array_u32(api_shape, api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_from_array_u64_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_from_array_u64",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_shape = <Option<Vec<i64>>>::sse_decode(&mut deserializer);
            let api_data = <Vec<u64>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::tensor::TensorImpl::from_array_u64(api_shape, api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_from_array_u8_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_from_array_u8",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_shape = <Option<Vec<i64>>>::sse_decode(&mut deserializer);
            let api_data = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::tensor::TensorImpl::from_array_u8(api_shape, api_data)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_get_data_bool_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_get_data_bool_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::tensor::TensorImpl::get_data_bool_pointer(
                        &mut *api_that_guard,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_get_data_f32_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_get_data_f32_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::tensor::TensorImpl::get_data_f32_pointer(&mut *api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_get_data_f64_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_get_data_f64_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::tensor::TensorImpl::get_data_f64_pointer(&mut *api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_get_data_i16_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_get_data_i16_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::tensor::TensorImpl::get_data_i16_pointer(&mut *api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_get_data_i32_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_get_data_i32_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::tensor::TensorImpl::get_data_i32_pointer(&mut *api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_get_data_i64_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_get_data_i64_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::tensor::TensorImpl::get_data_i64_pointer(&mut *api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_get_data_i8_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_get_data_i8_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::tensor::TensorImpl::get_data_i8_pointer(&mut *api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_get_data_string_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_get_data_string_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok = crate::api::tensor::TensorImpl::get_data_string_pointer(
                        &mut *api_that_guard,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_get_data_u16_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_get_data_u16_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::tensor::TensorImpl::get_data_u16_pointer(&mut *api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_get_data_u32_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_get_data_u32_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::tensor::TensorImpl::get_data_u32_pointer(&mut *api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_get_data_u64_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_get_data_u64_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::tensor::TensorImpl::get_data_u64_pointer(&mut *api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_get_data_u8_pointer_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_get_data_u8_pointer",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_that_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_that, 0, true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_that_guard = Some(api_that.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_that_guard = api_that_guard.unwrap();
                    let output_ok =
                        crate::api::tensor::TensorImpl::get_data_u8_pointer(&mut *api_that_guard)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_is_mutable_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_is_mutable",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::tensor::TensorImpl::is_mutable(
                    &*api_that_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_memory_info_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_memory_info",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <TensorImpl>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::tensor::TensorImpl::memory_info(api_that)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__tensor__TensorImpl_shape_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "TensorImpl_shape",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_that_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_that, 0, false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_that_guard = Some(api_that.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_that_guard = api_that_guard.unwrap();
                let output_ok =
                    Result::<_, ()>::Ok(crate::api::tensor::TensorImpl::shape(&*api_that_guard))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__coreml__core_ml_execution_provider_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "core_ml_execution_provider_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::execution_providers::coreml::CoreMLExecutionProvider::default(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__execution_providers__coreml__core_ml_execution_provider_is_available_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "core_ml_execution_provider_is_available", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::coreml::CoreMLExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || {
                     let output_ok = crate::api::execution_providers::coreml::CoreMLExecutionProvider::is_available(&api_that)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__execution_providers__coreml__core_ml_execution_provider_name_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "core_ml_execution_provider_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::execution_providers::coreml::CoreMLExecutionProvider>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::coreml::CoreMLExecutionProvider::name(
                        &api_that,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__coreml__core_ml_execution_provider_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "core_ml_execution_provider_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::coreml::CoreMLExecutionProvider::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__coreml__core_ml_execution_provider_supported_by_platform_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "core_ml_execution_provider_supported_by_platform", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::coreml::CoreMLExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::execution_providers::coreml::CoreMLExecutionProvider::supported_by_platform(&api_that))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__execution_providers__cpu__cpu_execution_provider_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cpu_execution_provider_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::execution_providers::cpu::CPUExecutionProvider::default(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__execution_providers__cpu__cpu_execution_provider_is_available_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cpu_execution_provider_is_available",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::cpu::CPUExecutionProvider>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::execution_providers::cpu::CPUExecutionProvider::is_available(
                            &api_that,
                        )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__execution_providers__cpu__cpu_execution_provider_name_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cpu_execution_provider_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::cpu::CPUExecutionProvider>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::cpu::CPUExecutionProvider::name(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__cpu__cpu_execution_provider_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cpu_execution_provider_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::cpu::CPUExecutionProvider::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__cpu__cpu_execution_provider_supported_by_platform_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "cpu_execution_provider_supported_by_platform", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::cpu::CPUExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::execution_providers::cpu::CPUExecutionProvider::supported_by_platform(&api_that))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__execution_providers__cuda__cuda_execution_provider_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cuda_execution_provider_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::execution_providers::cuda::CUDAExecutionProvider::default(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__execution_providers__cuda__cuda_execution_provider_is_available_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cuda_execution_provider_is_available",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::execution_providers::cuda::CUDAExecutionProvider>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::execution_providers::cuda::CUDAExecutionProvider::is_available(
                            &api_that,
                        )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__execution_providers__cuda__cuda_execution_provider_name_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cuda_execution_provider_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::execution_providers::cuda::CUDAExecutionProvider>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::cuda::CUDAExecutionProvider::name(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__cuda__cuda_execution_provider_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "cuda_execution_provider_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::cuda::CUDAExecutionProvider::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__cuda__cuda_execution_provider_supported_by_platform_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "cuda_execution_provider_supported_by_platform", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::cuda::CUDAExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::execution_providers::cuda::CUDAExecutionProvider::supported_by_platform(&api_that))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__execution_providers__directml__direct_ml_execution_provider_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "direct_ml_execution_provider_default", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::execution_providers::directml::DirectMLExecutionProvider::default())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__execution_providers__directml__direct_ml_execution_provider_is_available_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "direct_ml_execution_provider_is_available", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::directml::DirectMLExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || {
                     let output_ok = crate::api::execution_providers::directml::DirectMLExecutionProvider::is_available(&api_that)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__execution_providers__directml__direct_ml_execution_provider_name_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "direct_ml_execution_provider_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::execution_providers::directml::DirectMLExecutionProvider>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::directml::DirectMLExecutionProvider::name(
                        &api_that,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__directml__direct_ml_execution_provider_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "direct_ml_execution_provider_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::directml::DirectMLExecutionProvider::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__directml__direct_ml_execution_provider_supported_by_platform_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "direct_ml_execution_provider_supported_by_platform", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::directml::DirectMLExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::execution_providers::directml::DirectMLExecutionProvider::supported_by_platform(&api_that))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__init_app_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "init_app",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok({
                        crate::api::init_app();
                    })?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__execution_providers__nnapi__nnapi_execution_provider_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "nnapi_execution_provider_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::execution_providers::nnapi::NNAPIExecutionProvider::default(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__execution_providers__nnapi__nnapi_execution_provider_is_available_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "nnapi_execution_provider_is_available", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::nnapi::NNAPIExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || {
                     let output_ok = crate::api::execution_providers::nnapi::NNAPIExecutionProvider::is_available(&api_that)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__execution_providers__nnapi__nnapi_execution_provider_name_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "nnapi_execution_provider_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::execution_providers::nnapi::NNAPIExecutionProvider>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::nnapi::NNAPIExecutionProvider::name(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__nnapi__nnapi_execution_provider_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "nnapi_execution_provider_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::nnapi::NNAPIExecutionProvider::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__nnapi__nnapi_execution_provider_supported_by_platform_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "nnapi_execution_provider_supported_by_platform", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::nnapi::NNAPIExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::execution_providers::nnapi::NNAPIExecutionProvider::supported_by_platform(&api_that))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__logging__ort_debug_messages_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ort_debug_messages",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_level =
                <Option<crate::api::logging::OrtDebugLevel>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok({
                    crate::api::logging::ort_debug_messages(api_level);
                })?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__qnn__qnn_execution_provider_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "qnn_execution_provider_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::execution_providers::qnn::QNNExecutionProvider::default(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__execution_providers__qnn__qnn_execution_provider_is_available_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "qnn_execution_provider_is_available",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::qnn::QNNExecutionProvider>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::execution_providers::qnn::QNNExecutionProvider::is_available(
                            &api_that,
                        )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__execution_providers__qnn__qnn_execution_provider_name_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "qnn_execution_provider_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::qnn::QNNExecutionProvider>::sse_decode(
                &mut deserializer,
            );
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::qnn::QNNExecutionProvider::name(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__qnn__qnn_execution_provider_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "qnn_execution_provider_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::qnn::QNNExecutionProvider::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__qnn__qnn_execution_provider_supported_by_platform_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "qnn_execution_provider_supported_by_platform", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::qnn::QNNExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::execution_providers::qnn::QNNExecutionProvider::supported_by_platform(&api_that))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__execution_providers__rocm__ro_cm_execution_provider_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ro_cm_execution_provider_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::execution_providers::rocm::ROCmExecutionProvider::default(),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__execution_providers__rocm__ro_cm_execution_provider_is_available_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ro_cm_execution_provider_is_available",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::execution_providers::rocm::ROCmExecutionProvider>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok =
                        crate::api::execution_providers::rocm::ROCmExecutionProvider::is_available(
                            &api_that,
                        )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__execution_providers__rocm__ro_cm_execution_provider_name_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ro_cm_execution_provider_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::execution_providers::rocm::ROCmExecutionProvider>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::rocm::ROCmExecutionProvider::name(&api_that),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__rocm__ro_cm_execution_provider_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "ro_cm_execution_provider_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::rocm::ROCmExecutionProvider::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__rocm__ro_cm_execution_provider_supported_by_platform_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "ro_cm_execution_provider_supported_by_platform", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::rocm::ROCmExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::execution_providers::rocm::ROCmExecutionProvider::supported_by_platform(&api_that))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__session__session_builder_options_commit_from_file_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "session_builder_options_commit_from_file",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::session::SessionBuilderOptions>::sse_decode(&mut deserializer);
            let api_model_filepath = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::session::SessionBuilderOptions::commit_from_file(
                                api_that,
                                api_model_filepath,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__session__session_builder_options_commit_from_memory_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "session_builder_options_commit_from_memory",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::session::SessionBuilderOptions>::sse_decode(&mut deserializer);
            let api_model_bytes = <Vec<u8>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || {
                        let output_ok =
                            crate::api::session::SessionBuilderOptions::commit_from_memory(
                                api_that,
                                &api_model_bytes,
                            )?;
                        Ok(output_ok)
                    })(),
                )
            }
        },
    )
}
fn wire__crate__api__session__session_builder_options_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "session_builder_options_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok =
                        Result::<_, ()>::Ok(crate::api::session::SessionBuilderOptions::default())?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__execution_providers__tensorrt__tensor_rt_execution_provider_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec,_,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "tensor_rt_execution_provider_default", port: Some(port_), mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end(); move |context|  {
                    transform_result_sse::<_, ()>((move ||  {
                         let output_ok = Result::<_,()>::Ok(crate::api::execution_providers::tensorrt::TensorRTExecutionProvider::default())?;   Ok(output_ok)
                    })())
                } })
}
fn wire__crate__api__execution_providers__tensorrt__tensor_rt_execution_provider_is_available_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "tensor_rt_execution_provider_is_available", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::tensorrt::TensorRTExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || {
                     let output_ok = crate::api::execution_providers::tensorrt::TensorRTExecutionProvider::is_available(&api_that)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__execution_providers__tensorrt__tensor_rt_execution_provider_name_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "tensor_rt_execution_provider_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::execution_providers::tensorrt::TensorRTExecutionProvider>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::tensorrt::TensorRTExecutionProvider::name(
                        &api_that,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__tensorrt__tensor_rt_execution_provider_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "tensor_rt_execution_provider_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::tensorrt::TensorRTExecutionProvider::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__tensorrt__tensor_rt_execution_provider_supported_by_platform_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "tensor_rt_execution_provider_supported_by_platform", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::tensorrt::TensorRTExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::execution_providers::tensorrt::TensorRTExecutionProvider::supported_by_platform(&api_that))?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__execution_providers__xnnpack__xnnpack_execution_provider_default_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_normal::<flutter_rust_bridge::for_generated::SseCodec, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "xnnpack_execution_provider_default",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            move |context| {
                transform_result_sse::<_, ()>((move || {
                    let output_ok = Result::<_, ()>::Ok(
                        crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider::default(
                        ),
                    )?;
                    Ok(output_ok)
                })())
            }
        },
    )
}
fn wire__crate__api__execution_providers__xnnpack__xnnpack_execution_provider_is_available_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "xnnpack_execution_provider_is_available", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>((move || {
                     let output_ok = crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider::is_available(&api_that)?;   Ok(output_ok)
                })()) })
}
fn wire__crate__api__execution_providers__xnnpack__xnnpack_execution_provider_name_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "xnnpack_execution_provider_name",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that =
                <crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider>::sse_decode(
                    &mut deserializer,
                );
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider::name(
                        &api_that,
                    ),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__xnnpack__xnnpack_execution_provider_new_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "xnnpack_execution_provider_new",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let output_ok = Result::<_, ()>::Ok(
                    crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider::new(),
                )?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__execution_providers__xnnpack__xnnpack_execution_provider_supported_by_platform_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec,_>(flutter_rust_bridge::for_generated::TaskInfo{ debug_name: "xnnpack_execution_provider_supported_by_platform", port: None, mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync }, move || { 
            let message = unsafe { flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(ptr_, rust_vec_len_, data_len_) };
            let mut deserializer = flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_that = <crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider>::sse_decode(&mut deserializer);deserializer.end();
                transform_result_sse::<_, ()>((move || {
                     let output_ok = Result::<_,()>::Ok(crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider::supported_by_platform(&api_that))?;   Ok(output_ok)
                })()) })
}

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>
);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for MemoryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for SessionImpl {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for TensorImpl {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for std::collections::HashMap<String, TensorImpl> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<(String, TensorImpl)>>::sse_decode(deserializer);
        return inner.into_iter().collect();
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for crate::api::memory::AllocationDevice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::api::memory::AllocationDevice::Cpu;
            }
            1 => {
                return crate::api::memory::AllocationDevice::Cuda;
            }
            2 => {
                return crate::api::memory::AllocationDevice::CudaPinned;
            }
            3 => {
                return crate::api::memory::AllocationDevice::Cann;
            }
            4 => {
                return crate::api::memory::AllocationDevice::CannPinned;
            }
            5 => {
                return crate::api::memory::AllocationDevice::DirectML;
            }
            6 => {
                return crate::api::memory::AllocationDevice::Hip;
            }
            7 => {
                return crate::api::memory::AllocationDevice::HipPinned;
            }
            8 => {
                return crate::api::memory::AllocationDevice::OpenVinoCpu;
            }
            9 => {
                return crate::api::memory::AllocationDevice::OpenVinoGpu;
            }
            10 => {
                return crate::api::memory::AllocationDevice::QnnHtpShared;
            }
            11 => {
                return crate::api::memory::AllocationDevice::WebGpuBuffer;
            }
            12 => {
                let mut var_field0 = <String>::sse_decode(deserializer);
                return crate::api::memory::AllocationDevice::Other(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for crate::api::memory::AllocatorType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::memory::AllocatorType::Device,
            1 => crate::api::memory::AllocatorType::Arena,
            _ => unreachable!("Invalid variant for AllocatorType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::execution_providers::ArenaExtendStrategy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::execution_providers::ArenaExtendStrategy::NextPowerOfTwo,
            1 => crate::api::execution_providers::ArenaExtendStrategy::SameAsRequested,
            _ => unreachable!("Invalid variant for ArenaExtendStrategy: {}", inner),
        };
    }
}

impl SseDecode for crate::api::tensor::ArrayPointer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_ptr = <usize>::sse_decode(deserializer);
        let mut var_len = <usize>::sse_decode(deserializer);
        return crate::api::tensor::ArrayPointer {
            ptr: var_ptr,
            len: var_len,
        };
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::api::execution_providers::coreml::CoreMLComputeUnits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::execution_providers::coreml::CoreMLComputeUnits::All,
            1 => crate::api::execution_providers::coreml::CoreMLComputeUnits::CPUAndNeuralEngine,
            2 => crate::api::execution_providers::coreml::CoreMLComputeUnits::CPUAndGPU,
            3 => crate::api::execution_providers::coreml::CoreMLComputeUnits::CPUOnly,
            _ => unreachable!("Invalid variant for CoreMLComputeUnits: {}", inner),
        };
    }
}

impl SseDecode for crate::api::execution_providers::coreml::CoreMLExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_subgraphs = <Option<bool>>::sse_decode(deserializer);
        let mut var_staticInputShapes = <Option<bool>>::sse_decode(deserializer);
        let mut var_modelFormat = <Option<
            crate::api::execution_providers::coreml::CoreMLModelFormat,
        >>::sse_decode(deserializer);
        let mut var_specializationStrategy = <Option<
            crate::api::execution_providers::coreml::CoreMLSpecializationStrategy,
        >>::sse_decode(deserializer);
        let mut var_computeUnits = <Option<
            crate::api::execution_providers::coreml::CoreMLComputeUnits,
        >>::sse_decode(deserializer);
        let mut var_profileComputePlan = <Option<bool>>::sse_decode(deserializer);
        let mut var_lowPrecisionAccumulationOnGpu = <Option<bool>>::sse_decode(deserializer);
        let mut var_modelCacheDir = <Option<String>>::sse_decode(deserializer);
        return crate::api::execution_providers::coreml::CoreMLExecutionProvider {
            subgraphs: var_subgraphs,
            static_input_shapes: var_staticInputShapes,
            model_format: var_modelFormat,
            specialization_strategy: var_specializationStrategy,
            compute_units: var_computeUnits,
            profile_compute_plan: var_profileComputePlan,
            low_precision_accumulation_on_gpu: var_lowPrecisionAccumulationOnGpu,
            model_cache_dir: var_modelCacheDir,
        };
    }
}

impl SseDecode for crate::api::execution_providers::coreml::CoreMLModelFormat {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::execution_providers::coreml::CoreMLModelFormat::MLProgram,
            1 => crate::api::execution_providers::coreml::CoreMLModelFormat::NeuralNetwork,
            _ => unreachable!("Invalid variant for CoreMLModelFormat: {}", inner),
        };
    }
}

impl SseDecode for crate::api::execution_providers::coreml::CoreMLSpecializationStrategy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::execution_providers::coreml::CoreMLSpecializationStrategy::Default,
1 => crate::api::execution_providers::coreml::CoreMLSpecializationStrategy::FastPrediction,
            _ => unreachable!("Invalid variant for CoreMLSpecializationStrategy: {}", inner),
        };
    }
}

impl SseDecode for crate::api::execution_providers::cpu::CPUExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        return crate::api::execution_providers::cpu::CPUExecutionProvider {};
    }
}

impl SseDecode for crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch::Exhaustive,
            1 => crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch::Heuristic,
            2 => crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch::Default,
            _ => unreachable!("Invalid variant for CuDNNConvAlgorithmSearch: {}", inner),
        };
    }
}

impl SseDecode for crate::api::execution_providers::cuda::CUDAAttentionBackend {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::execution_providers::cuda::CUDAAttentionBackend::FlashAttention,
            1 => crate::api::execution_providers::cuda::CUDAAttentionBackend::EfficientAttention,
            2 => crate::api::execution_providers::cuda::CUDAAttentionBackend::TrtFusedAttention,
            3 => crate::api::execution_providers::cuda::CUDAAttentionBackend::CudnnFlashAttention,
            4 => crate::api::execution_providers::cuda::CUDAAttentionBackend::Math,
            5 => crate::api::execution_providers::cuda::CUDAAttentionBackend::TrtFlashAttention,
            6 => crate::api::execution_providers::cuda::CUDAAttentionBackend::TrtCrossAttention,
            7 => crate::api::execution_providers::cuda::CUDAAttentionBackend::TrtCausalAttention,
            8 => crate::api::execution_providers::cuda::CUDAAttentionBackend::LeanAttention,
            9 => crate::api::execution_providers::cuda::CUDAAttentionBackend::None,
            10 => crate::api::execution_providers::cuda::CUDAAttentionBackend::All,
            _ => unreachable!("Invalid variant for CUDAAttentionBackend: {}", inner),
        };
    }
}

impl SseDecode for crate::api::execution_providers::cuda::CUDAExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_deviceId = <Option<i32>>::sse_decode(deserializer);
        let mut var_memoryLimit = <Option<usize>>::sse_decode(deserializer);
        let mut var_arenaExtendStrategy = <Option<
            crate::api::execution_providers::ArenaExtendStrategy,
        >>::sse_decode(deserializer);
        let mut var_convAlgorithmSearch = <Option<
            crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch,
        >>::sse_decode(deserializer);
        let mut var_convMaxWorkspace = <Option<bool>>::sse_decode(deserializer);
        let mut var_conv1DPadToNc1D = <Option<bool>>::sse_decode(deserializer);
        let mut var_cudaGraph = <Option<bool>>::sse_decode(deserializer);
        let mut var_skipLayerNormStrictMode = <Option<bool>>::sse_decode(deserializer);
        let mut var_tf32 = <Option<bool>>::sse_decode(deserializer);
        let mut var_preferNhwc = <Option<bool>>::sse_decode(deserializer);
        let mut var_attentionBackend = <Option<
            crate::api::execution_providers::cuda::CUDAAttentionBackend,
        >>::sse_decode(deserializer);
        let mut var_fuseConvBias = <Option<bool>>::sse_decode(deserializer);
        return crate::api::execution_providers::cuda::CUDAExecutionProvider {
            device_id: var_deviceId,
            memory_limit: var_memoryLimit,
            arena_extend_strategy: var_arenaExtendStrategy,
            conv_algorithm_search: var_convAlgorithmSearch,
            conv_max_workspace: var_convMaxWorkspace,
            conv1d_pad_to_nc1d: var_conv1DPadToNc1D,
            cuda_graph: var_cudaGraph,
            skip_layer_norm_strict_mode: var_skipLayerNormStrictMode,
            tf32: var_tf32,
            prefer_nhwc: var_preferNhwc,
            attention_backend: var_attentionBackend,
            fuse_conv_bias: var_fuseConvBias,
        };
    }
}

impl SseDecode for crate::api::memory::DeviceType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::memory::DeviceType::CPU,
            1 => crate::api::memory::DeviceType::GPU,
            2 => crate::api::memory::DeviceType::FPGA,
            _ => unreachable!("Invalid variant for DeviceType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::execution_providers::directml::DirectMLExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_deviceId = <Option<i32>>::sse_decode(deserializer);
        return crate::api::execution_providers::directml::DirectMLExecutionProvider {
            device_id: var_deviceId,
        };
    }
}

impl SseDecode for crate::api::execution_providers::ExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_field0 =
                    <crate::api::execution_providers::coreml::CoreMLExecutionProvider>::sse_decode(
                        deserializer,
                    );
                return crate::api::execution_providers::ExecutionProvider::CoreML(var_field0);
            }
            1 => {
                let mut var_field0 =
                    <crate::api::execution_providers::cpu::CPUExecutionProvider>::sse_decode(
                        deserializer,
                    );
                return crate::api::execution_providers::ExecutionProvider::CPU(var_field0);
            }
            2 => {
                let mut var_field0 =
                    <crate::api::execution_providers::cuda::CUDAExecutionProvider>::sse_decode(
                        deserializer,
                    );
                return crate::api::execution_providers::ExecutionProvider::CUDA(var_field0);
            }
            3 => {
                let mut var_field0 = <crate::api::execution_providers::directml::DirectMLExecutionProvider>::sse_decode(deserializer);
                return crate::api::execution_providers::ExecutionProvider::DirectML(var_field0);
            }
            4 => {
                let mut var_field0 =
                    <crate::api::execution_providers::nnapi::NNAPIExecutionProvider>::sse_decode(
                        deserializer,
                    );
                return crate::api::execution_providers::ExecutionProvider::NNApi(var_field0);
            }
            5 => {
                let mut var_field0 =
                    <crate::api::execution_providers::qnn::QNNExecutionProvider>::sse_decode(
                        deserializer,
                    );
                return crate::api::execution_providers::ExecutionProvider::QNN(var_field0);
            }
            6 => {
                let mut var_field0 =
                    <crate::api::execution_providers::rocm::ROCmExecutionProvider>::sse_decode(
                        deserializer,
                    );
                return crate::api::execution_providers::ExecutionProvider::ROCm(var_field0);
            }
            7 => {
                let mut var_field0 = <crate::api::execution_providers::tensorrt::TensorRTExecutionProvider>::sse_decode(deserializer);
                return crate::api::execution_providers::ExecutionProvider::TensorRT(var_field0);
            }
            8 => {
                let mut var_field0 = <crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider>::sse_decode(deserializer);
                return crate::api::execution_providers::ExecutionProvider::XNNPACK(var_field0);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseDecode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for crate::api::session::builder::impl_options::GraphOptimizationLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::session::builder::impl_options::GraphOptimizationLevel::Disable,
            1 => crate::api::session::builder::impl_options::GraphOptimizationLevel::Level1,
            2 => crate::api::session::builder::impl_options::GraphOptimizationLevel::Level2,
            3 => crate::api::session::builder::impl_options::GraphOptimizationLevel::Level3,
            _ => unreachable!("Invalid variant for GraphOptimizationLevel: {}", inner),
        };
    }
}

impl SseDecode for i16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i8().unwrap()
    }
}

impl SseDecode for crate::api::session::Input {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        return crate::api::session::Input { name: var_name };
    }
}

impl SseDecode for Vec<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<i64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<bool>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::execution_providers::ExecutionProvider> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(
                <crate::api::execution_providers::ExecutionProvider>::sse_decode(deserializer),
            );
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::session::Input> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::session::Input>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::api::session::Output> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::api::session::Output>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<f32>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<f64>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<i16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<i16>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<i32>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<i8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<i8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u16>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u32>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<(String, TensorImpl)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<(String, TensorImpl)>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for crate::api::memory::MemoryType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::memory::MemoryType::CPUInput,
            1 => crate::api::memory::MemoryType::CPUOutput,
            2 => crate::api::memory::MemoryType::Default,
            _ => unreachable!("Invalid variant for MemoryType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::execution_providers::nnapi::NNAPIExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_fp16 = <Option<bool>>::sse_decode(deserializer);
        let mut var_nchw = <Option<bool>>::sse_decode(deserializer);
        let mut var_disableCpu = <Option<bool>>::sse_decode(deserializer);
        let mut var_cpuOnly = <Option<bool>>::sse_decode(deserializer);
        return crate::api::execution_providers::nnapi::NNAPIExecutionProvider {
            fp16: var_fp16,
            nchw: var_nchw,
            disable_cpu: var_disableCpu,
            cpu_only: var_cpuOnly,
        };
    }
}

impl SseDecode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<usize>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::execution_providers::ArenaExtendStrategy> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::execution_providers::ArenaExtendStrategy>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::execution_providers::coreml::CoreMLComputeUnits> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::execution_providers::coreml::CoreMLComputeUnits>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::execution_providers::coreml::CoreMLModelFormat> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::execution_providers::coreml::CoreMLModelFormat>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::execution_providers::coreml::CoreMLSpecializationStrategy> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::execution_providers::coreml::CoreMLSpecializationStrategy>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::execution_providers::cuda::CUDAAttentionBackend> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::execution_providers::cuda::CUDAAttentionBackend>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::session::builder::impl_options::GraphOptimizationLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::session::builder::impl_options::GraphOptimizationLevel>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::logging::OrtDebugLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::api::logging::OrtDebugLevel>::sse_decode(
                deserializer,
            ));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::execution_providers::qnn::QNNContextPriority> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::execution_providers::qnn::QNNContextPriority>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::execution_providers::qnn::QNNPerformanceMode> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::execution_providers::qnn::QNNPerformanceMode>::sse_decode(
                    deserializer,
                ),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::api::execution_providers::qnn::QNNProfilingLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <crate::api::execution_providers::qnn::QNNProfilingLevel>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<u8>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<i64>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<Vec<i64>>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<Vec<crate::api::execution_providers::ExecutionProvider>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(
                <Vec<crate::api::execution_providers::ExecutionProvider>>::sse_decode(deserializer),
            );
        } else {
            return None;
        }
    }
}

impl SseDecode for crate::api::logging::OrtDebugLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::logging::OrtDebugLevel::Trace,
            1 => crate::api::logging::OrtDebugLevel::Debug,
            2 => crate::api::logging::OrtDebugLevel::Info,
            3 => crate::api::logging::OrtDebugLevel::Warn,
            4 => crate::api::logging::OrtDebugLevel::Error,
            _ => unreachable!("Invalid variant for OrtDebugLevel: {}", inner),
        };
    }
}

impl SseDecode for crate::api::session::Output {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        return crate::api::session::Output { name: var_name };
    }
}

impl SseDecode for crate::api::execution_providers::qnn::QNNContextPriority {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::execution_providers::qnn::QNNContextPriority::Low,
            1 => crate::api::execution_providers::qnn::QNNContextPriority::Normal,
            2 => crate::api::execution_providers::qnn::QNNContextPriority::NormalHigh,
            3 => crate::api::execution_providers::qnn::QNNContextPriority::High,
            _ => unreachable!("Invalid variant for QNNContextPriority: {}", inner),
        };
    }
}

impl SseDecode for crate::api::execution_providers::qnn::QNNExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_backendPath = <Option<String>>::sse_decode(deserializer);
        let mut var_profiling =
            <Option<crate::api::execution_providers::qnn::QNNProfilingLevel>>::sse_decode(
                deserializer,
            );
        let mut var_profilingPath = <Option<String>>::sse_decode(deserializer);
        let mut var_rpcControlLatency = <Option<u32>>::sse_decode(deserializer);
        let mut var_vtcmMb = <Option<usize>>::sse_decode(deserializer);
        let mut var_performanceMode = <Option<
            crate::api::execution_providers::qnn::QNNPerformanceMode,
        >>::sse_decode(deserializer);
        let mut var_saverPath = <Option<String>>::sse_decode(deserializer);
        let mut var_contextPriority = <Option<
            crate::api::execution_providers::qnn::QNNContextPriority,
        >>::sse_decode(deserializer);
        let mut var_htpGraphFinalizationOptimizationMode = <Option<u8>>::sse_decode(deserializer);
        let mut var_socModel = <Option<String>>::sse_decode(deserializer);
        let mut var_htpArch = <Option<u32>>::sse_decode(deserializer);
        let mut var_deviceId = <Option<i32>>::sse_decode(deserializer);
        let mut var_htpFp16Precision = <Option<bool>>::sse_decode(deserializer);
        let mut var_offloadGraphIoQuantization = <Option<bool>>::sse_decode(deserializer);
        return crate::api::execution_providers::qnn::QNNExecutionProvider {
            backend_path: var_backendPath,
            profiling: var_profiling,
            profiling_path: var_profilingPath,
            rpc_control_latency: var_rpcControlLatency,
            vtcm_mb: var_vtcmMb,
            performance_mode: var_performanceMode,
            saver_path: var_saverPath,
            context_priority: var_contextPriority,
            htp_graph_finalization_optimization_mode: var_htpGraphFinalizationOptimizationMode,
            soc_model: var_socModel,
            htp_arch: var_htpArch,
            device_id: var_deviceId,
            htp_fp16_precision: var_htpFp16Precision,
            offload_graph_io_quantization: var_offloadGraphIoQuantization,
        };
    }
}

impl SseDecode for crate::api::execution_providers::qnn::QNNPerformanceMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::execution_providers::qnn::QNNPerformanceMode::Default,
            1 => crate::api::execution_providers::qnn::QNNPerformanceMode::Burst,
            2 => crate::api::execution_providers::qnn::QNNPerformanceMode::Balanced,
            3 => crate::api::execution_providers::qnn::QNNPerformanceMode::HighPerformance,
            4 => crate::api::execution_providers::qnn::QNNPerformanceMode::HighPowerSaver,
            5 => crate::api::execution_providers::qnn::QNNPerformanceMode::LowPowerSaver,
            6 => crate::api::execution_providers::qnn::QNNPerformanceMode::LowBalanced,
            7 => crate::api::execution_providers::qnn::QNNPerformanceMode::PowerSaver,
            8 => crate::api::execution_providers::qnn::QNNPerformanceMode::ExtremePowerSaver,
            9 => crate::api::execution_providers::qnn::QNNPerformanceMode::SustainedHighPerformance,
            _ => unreachable!("Invalid variant for QNNPerformanceMode: {}", inner),
        };
    }
}

impl SseDecode for crate::api::execution_providers::qnn::QNNProfilingLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::execution_providers::qnn::QNNProfilingLevel::Off,
            1 => crate::api::execution_providers::qnn::QNNProfilingLevel::Basic,
            2 => crate::api::execution_providers::qnn::QNNProfilingLevel::Detailed,
            _ => unreachable!("Invalid variant for QNNProfilingLevel: {}", inner),
        };
    }
}

impl SseDecode for (String, TensorImpl) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_field0 = <String>::sse_decode(deserializer);
        let mut var_field1 = <TensorImpl>::sse_decode(deserializer);
        return (var_field0, var_field1);
    }
}

impl SseDecode for crate::api::execution_providers::rocm::ROCmExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_deviceId = <Option<i32>>::sse_decode(deserializer);
        let mut var_exhaustiveConvSearch = <Option<bool>>::sse_decode(deserializer);
        let mut var_convUseMaxWorkspace = <Option<bool>>::sse_decode(deserializer);
        let mut var_memLimit = <Option<usize>>::sse_decode(deserializer);
        let mut var_arenaExtendStrategy = <Option<
            crate::api::execution_providers::ArenaExtendStrategy,
        >>::sse_decode(deserializer);
        let mut var_copyInDefaultStream = <Option<bool>>::sse_decode(deserializer);
        let mut var_hipGraph = <Option<bool>>::sse_decode(deserializer);
        let mut var_tunableOp = <Option<bool>>::sse_decode(deserializer);
        let mut var_tuning = <Option<bool>>::sse_decode(deserializer);
        let mut var_maxTuningDuration = <Option<i32>>::sse_decode(deserializer);
        return crate::api::execution_providers::rocm::ROCmExecutionProvider {
            device_id: var_deviceId,
            exhaustive_conv_search: var_exhaustiveConvSearch,
            conv_use_max_workspace: var_convUseMaxWorkspace,
            mem_limit: var_memLimit,
            arena_extend_strategy: var_arenaExtendStrategy,
            copy_in_default_stream: var_copyInDefaultStream,
            hip_graph: var_hipGraph,
            tunable_op: var_tunableOp,
            tuning: var_tuning,
            max_tuning_duration: var_maxTuningDuration,
        };
    }
}

impl SseDecode for crate::api::session::SessionBuilderOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_executionProviders = <Option<
            Vec<crate::api::execution_providers::ExecutionProvider>,
        >>::sse_decode(deserializer);
        let mut var_intraThreads = <Option<usize>>::sse_decode(deserializer);
        let mut var_interThreads = <Option<usize>>::sse_decode(deserializer);
        let mut var_parallelExecution = <Option<bool>>::sse_decode(deserializer);
        let mut var_optimizationLevel = <Option<
            crate::api::session::builder::impl_options::GraphOptimizationLevel,
        >>::sse_decode(deserializer);
        let mut var_memoryPattern = <Option<bool>>::sse_decode(deserializer);
        return crate::api::session::SessionBuilderOptions {
            execution_providers: var_executionProviders,
            intra_threads: var_intraThreads,
            inter_threads: var_interThreads,
            parallel_execution: var_parallelExecution,
            optimization_level: var_optimizationLevel,
            memory_pattern: var_memoryPattern,
        };
    }
}

impl SseDecode for crate::api::tensor::TensorElementType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <i32>::sse_decode(deserializer);
        return match inner {
            0 => crate::api::tensor::TensorElementType::Float32,
            1 => crate::api::tensor::TensorElementType::Uint8,
            2 => crate::api::tensor::TensorElementType::Int8,
            3 => crate::api::tensor::TensorElementType::Uint16,
            4 => crate::api::tensor::TensorElementType::Int16,
            5 => crate::api::tensor::TensorElementType::Int32,
            6 => crate::api::tensor::TensorElementType::Int64,
            7 => crate::api::tensor::TensorElementType::String,
            8 => crate::api::tensor::TensorElementType::Bool,
            9 => crate::api::tensor::TensorElementType::Float16,
            10 => crate::api::tensor::TensorElementType::Float64,
            11 => crate::api::tensor::TensorElementType::Uint32,
            12 => crate::api::tensor::TensorElementType::Uint64,
            13 => crate::api::tensor::TensorElementType::Bfloat16,
            14 => crate::api::tensor::TensorElementType::Complex64,
            15 => crate::api::tensor::TensorElementType::Complex128,
            16 => crate::api::tensor::TensorElementType::Float8E4M3FN,
            17 => crate::api::tensor::TensorElementType::Float8E4M3FNUZ,
            18 => crate::api::tensor::TensorElementType::Float8E5M2,
            19 => crate::api::tensor::TensorElementType::Float8E5M2FNUZ,
            20 => crate::api::tensor::TensorElementType::Uint4,
            21 => crate::api::tensor::TensorElementType::Int4,
            22 => crate::api::tensor::TensorElementType::Undefined,
            _ => unreachable!("Invalid variant for TensorElementType: {}", inner),
        };
    }
}

impl SseDecode for crate::api::execution_providers::tensorrt::TensorRTExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_deviceId = <Option<i32>>::sse_decode(deserializer);
        let mut var_maxWorkspaceSize = <Option<usize>>::sse_decode(deserializer);
        let mut var_minSubgraphSize = <Option<usize>>::sse_decode(deserializer);
        let mut var_maxPartitionIterations = <Option<u32>>::sse_decode(deserializer);
        let mut var_fp16 = <Option<bool>>::sse_decode(deserializer);
        let mut var_int8 = <Option<bool>>::sse_decode(deserializer);
        let mut var_dla = <Option<bool>>::sse_decode(deserializer);
        let mut var_dlaCore = <Option<u32>>::sse_decode(deserializer);
        let mut var_int8CalibrationTableName = <Option<String>>::sse_decode(deserializer);
        let mut var_int8UseNativeCalibrationTable = <Option<bool>>::sse_decode(deserializer);
        let mut var_engineCache = <Option<bool>>::sse_decode(deserializer);
        let mut var_engineCachePath = <Option<String>>::sse_decode(deserializer);
        let mut var_dumpSubgraphs = <Option<bool>>::sse_decode(deserializer);
        let mut var_engineCachePrefix = <Option<String>>::sse_decode(deserializer);
        let mut var_weightStrippedEngine = <Option<bool>>::sse_decode(deserializer);
        let mut var_onnxModelFolderPath = <Option<String>>::sse_decode(deserializer);
        let mut var_engineDecryption = <Option<bool>>::sse_decode(deserializer);
        let mut var_engineDecryptionLibPath = <Option<String>>::sse_decode(deserializer);
        let mut var_forceSequentialEngineBuild = <Option<bool>>::sse_decode(deserializer);
        let mut var_contextMemorySharing = <Option<bool>>::sse_decode(deserializer);
        let mut var_layerNormFp32Fallback = <Option<bool>>::sse_decode(deserializer);
        let mut var_timingCache = <Option<bool>>::sse_decode(deserializer);
        let mut var_timingCachePath = <Option<String>>::sse_decode(deserializer);
        let mut var_forceTimingCache = <Option<bool>>::sse_decode(deserializer);
        let mut var_detailedBuildLog = <Option<bool>>::sse_decode(deserializer);
        let mut var_buildHeuristics = <Option<bool>>::sse_decode(deserializer);
        let mut var_sparsity = <Option<bool>>::sse_decode(deserializer);
        let mut var_builderOptimizationLevel = <Option<u8>>::sse_decode(deserializer);
        let mut var_auxiliaryStreams = <Option<i8>>::sse_decode(deserializer);
        let mut var_tacticSources = <Option<String>>::sse_decode(deserializer);
        let mut var_extraPluginLibPaths = <Option<String>>::sse_decode(deserializer);
        let mut var_profileMinShapes = <Option<String>>::sse_decode(deserializer);
        let mut var_profileMaxShapes = <Option<String>>::sse_decode(deserializer);
        let mut var_profileOptShapes = <Option<String>>::sse_decode(deserializer);
        let mut var_cudaGraph = <Option<bool>>::sse_decode(deserializer);
        let mut var_dumpEpContextModel = <Option<bool>>::sse_decode(deserializer);
        let mut var_epContextFilePath = <Option<String>>::sse_decode(deserializer);
        let mut var_epContextEmbedMode = <Option<u8>>::sse_decode(deserializer);
        let mut var_engineHwCompatible = <Option<bool>>::sse_decode(deserializer);
        return crate::api::execution_providers::tensorrt::TensorRTExecutionProvider {
            device_id: var_deviceId,
            max_workspace_size: var_maxWorkspaceSize,
            min_subgraph_size: var_minSubgraphSize,
            max_partition_iterations: var_maxPartitionIterations,
            fp16: var_fp16,
            int8: var_int8,
            dla: var_dla,
            dla_core: var_dlaCore,
            int8_calibration_table_name: var_int8CalibrationTableName,
            int8_use_native_calibration_table: var_int8UseNativeCalibrationTable,
            engine_cache: var_engineCache,
            engine_cache_path: var_engineCachePath,
            dump_subgraphs: var_dumpSubgraphs,
            engine_cache_prefix: var_engineCachePrefix,
            weight_stripped_engine: var_weightStrippedEngine,
            onnx_model_folder_path: var_onnxModelFolderPath,
            engine_decryption: var_engineDecryption,
            engine_decryption_lib_path: var_engineDecryptionLibPath,
            force_sequential_engine_build: var_forceSequentialEngineBuild,
            context_memory_sharing: var_contextMemorySharing,
            layer_norm_fp32_fallback: var_layerNormFp32Fallback,
            timing_cache: var_timingCache,
            timing_cache_path: var_timingCachePath,
            force_timing_cache: var_forceTimingCache,
            detailed_build_log: var_detailedBuildLog,
            build_heuristics: var_buildHeuristics,
            sparsity: var_sparsity,
            builder_optimization_level: var_builderOptimizationLevel,
            auxiliary_streams: var_auxiliaryStreams,
            tactic_sources: var_tacticSources,
            extra_plugin_lib_paths: var_extraPluginLibPaths,
            profile_min_shapes: var_profileMinShapes,
            profile_max_shapes: var_profileMaxShapes,
            profile_opt_shapes: var_profileOptShapes,
            cuda_graph: var_cudaGraph,
            dump_ep_context_model: var_dumpEpContextModel,
            ep_context_file_path: var_epContextFilePath,
            ep_context_embed_mode: var_epContextEmbedMode,
            engine_hw_compatible: var_engineHwCompatible,
        };
    }
}

impl SseDecode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u16::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

impl SseDecode for crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_intraOpNumThreads = <Option<usize>>::sse_decode(deserializer);
        return crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider {
            intra_op_num_threads: var_intraOpNumThreads,
        };
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
                        10 => wire__crate__api__session__SessionImpl_run_impl(port, ptr, rust_vec_len, data_len),
55 => wire__crate__api__execution_providers__coreml__core_ml_execution_provider_default_impl(port, ptr, rust_vec_len, data_len),
60 => wire__crate__api__execution_providers__cpu__cpu_execution_provider_default_impl(port, ptr, rust_vec_len, data_len),
65 => wire__crate__api__execution_providers__cuda__cuda_execution_provider_default_impl(port, ptr, rust_vec_len, data_len),
70 => wire__crate__api__execution_providers__directml__direct_ml_execution_provider_default_impl(port, ptr, rust_vec_len, data_len),
75 => wire__crate__api__init_app_impl(port, ptr, rust_vec_len, data_len),
76 => wire__crate__api__execution_providers__nnapi__nnapi_execution_provider_default_impl(port, ptr, rust_vec_len, data_len),
82 => wire__crate__api__execution_providers__qnn__qnn_execution_provider_default_impl(port, ptr, rust_vec_len, data_len),
87 => wire__crate__api__execution_providers__rocm__ro_cm_execution_provider_default_impl(port, ptr, rust_vec_len, data_len),
92 => wire__crate__api__session__session_builder_options_commit_from_file_impl(port, ptr, rust_vec_len, data_len),
93 => wire__crate__api__session__session_builder_options_commit_from_memory_impl(port, ptr, rust_vec_len, data_len),
94 => wire__crate__api__session__session_builder_options_default_impl(port, ptr, rust_vec_len, data_len),
95 => wire__crate__api__execution_providers__tensorrt__tensor_rt_execution_provider_default_impl(port, ptr, rust_vec_len, data_len),
100 => wire__crate__api__execution_providers__xnnpack__xnnpack_execution_provider_default_impl(port, ptr, rust_vec_len, data_len),
                        _ => unreachable!(),
                    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
                        1 => wire__crate__api__memory__MemoryInfo_allocation_device_impl(ptr, rust_vec_len, data_len),
2 => wire__crate__api__memory__MemoryInfo_allocator_type_impl(ptr, rust_vec_len, data_len),
3 => wire__crate__api__memory__MemoryInfo_device_id_impl(ptr, rust_vec_len, data_len),
4 => wire__crate__api__memory__MemoryInfo_device_type_impl(ptr, rust_vec_len, data_len),
5 => wire__crate__api__memory__MemoryInfo_is_cpu_accessible_impl(ptr, rust_vec_len, data_len),
6 => wire__crate__api__memory__MemoryInfo_memory_type_impl(ptr, rust_vec_len, data_len),
7 => wire__crate__api__session__SessionImpl_builder_impl(ptr, rust_vec_len, data_len),
8 => wire__crate__api__session__SessionImpl_inputs_impl(ptr, rust_vec_len, data_len),
9 => wire__crate__api__session__SessionImpl_outputs_impl(ptr, rust_vec_len, data_len),
11 => wire__crate__api__tensor__TensorImpl_clone_impl(ptr, rust_vec_len, data_len),
12 => wire__crate__api__tensor__TensorImpl_dtype_impl(ptr, rust_vec_len, data_len),
13 => wire__crate__api__tensor__TensorImpl_free_bool_pointer_impl(ptr, rust_vec_len, data_len),
14 => wire__crate__api__tensor__TensorImpl_free_f32_pointer_impl(ptr, rust_vec_len, data_len),
15 => wire__crate__api__tensor__TensorImpl_free_f64_pointer_impl(ptr, rust_vec_len, data_len),
16 => wire__crate__api__tensor__TensorImpl_free_i16_pointer_impl(ptr, rust_vec_len, data_len),
17 => wire__crate__api__tensor__TensorImpl_free_i32_pointer_impl(ptr, rust_vec_len, data_len),
18 => wire__crate__api__tensor__TensorImpl_free_i64_pointer_impl(ptr, rust_vec_len, data_len),
19 => wire__crate__api__tensor__TensorImpl_free_i8_pointer_impl(ptr, rust_vec_len, data_len),
20 => wire__crate__api__tensor__TensorImpl_free_string_pointer_impl(ptr, rust_vec_len, data_len),
21 => wire__crate__api__tensor__TensorImpl_free_u16_pointer_impl(ptr, rust_vec_len, data_len),
22 => wire__crate__api__tensor__TensorImpl_free_u32_pointer_impl(ptr, rust_vec_len, data_len),
23 => wire__crate__api__tensor__TensorImpl_free_u64_pointer_impl(ptr, rust_vec_len, data_len),
24 => wire__crate__api__tensor__TensorImpl_free_u8_pointer_impl(ptr, rust_vec_len, data_len),
25 => wire__crate__api__tensor__TensorImpl_from_array_bool_impl(ptr, rust_vec_len, data_len),
26 => wire__crate__api__tensor__TensorImpl_from_array_f32_impl(ptr, rust_vec_len, data_len),
27 => wire__crate__api__tensor__TensorImpl_from_array_f64_impl(ptr, rust_vec_len, data_len),
28 => wire__crate__api__tensor__TensorImpl_from_array_i16_impl(ptr, rust_vec_len, data_len),
29 => wire__crate__api__tensor__TensorImpl_from_array_i32_impl(ptr, rust_vec_len, data_len),
30 => wire__crate__api__tensor__TensorImpl_from_array_i64_impl(ptr, rust_vec_len, data_len),
31 => wire__crate__api__tensor__TensorImpl_from_array_i8_impl(ptr, rust_vec_len, data_len),
32 => wire__crate__api__tensor__TensorImpl_from_array_string_impl(ptr, rust_vec_len, data_len),
33 => wire__crate__api__tensor__TensorImpl_from_array_u16_impl(ptr, rust_vec_len, data_len),
34 => wire__crate__api__tensor__TensorImpl_from_array_u32_impl(ptr, rust_vec_len, data_len),
35 => wire__crate__api__tensor__TensorImpl_from_array_u64_impl(ptr, rust_vec_len, data_len),
36 => wire__crate__api__tensor__TensorImpl_from_array_u8_impl(ptr, rust_vec_len, data_len),
37 => wire__crate__api__tensor__TensorImpl_get_data_bool_pointer_impl(ptr, rust_vec_len, data_len),
38 => wire__crate__api__tensor__TensorImpl_get_data_f32_pointer_impl(ptr, rust_vec_len, data_len),
39 => wire__crate__api__tensor__TensorImpl_get_data_f64_pointer_impl(ptr, rust_vec_len, data_len),
40 => wire__crate__api__tensor__TensorImpl_get_data_i16_pointer_impl(ptr, rust_vec_len, data_len),
41 => wire__crate__api__tensor__TensorImpl_get_data_i32_pointer_impl(ptr, rust_vec_len, data_len),
42 => wire__crate__api__tensor__TensorImpl_get_data_i64_pointer_impl(ptr, rust_vec_len, data_len),
43 => wire__crate__api__tensor__TensorImpl_get_data_i8_pointer_impl(ptr, rust_vec_len, data_len),
44 => wire__crate__api__tensor__TensorImpl_get_data_string_pointer_impl(ptr, rust_vec_len, data_len),
45 => wire__crate__api__tensor__TensorImpl_get_data_u16_pointer_impl(ptr, rust_vec_len, data_len),
46 => wire__crate__api__tensor__TensorImpl_get_data_u32_pointer_impl(ptr, rust_vec_len, data_len),
47 => wire__crate__api__tensor__TensorImpl_get_data_u64_pointer_impl(ptr, rust_vec_len, data_len),
48 => wire__crate__api__tensor__TensorImpl_get_data_u8_pointer_impl(ptr, rust_vec_len, data_len),
49 => wire__crate__api__tensor__TensorImpl_is_mutable_impl(ptr, rust_vec_len, data_len),
50 => wire__crate__api__tensor__TensorImpl_memory_info_impl(ptr, rust_vec_len, data_len),
51 => wire__crate__api__tensor__TensorImpl_shape_impl(ptr, rust_vec_len, data_len),
56 => wire__crate__api__execution_providers__coreml__core_ml_execution_provider_is_available_impl(ptr, rust_vec_len, data_len),
57 => wire__crate__api__execution_providers__coreml__core_ml_execution_provider_name_impl(ptr, rust_vec_len, data_len),
58 => wire__crate__api__execution_providers__coreml__core_ml_execution_provider_new_impl(ptr, rust_vec_len, data_len),
59 => wire__crate__api__execution_providers__coreml__core_ml_execution_provider_supported_by_platform_impl(ptr, rust_vec_len, data_len),
61 => wire__crate__api__execution_providers__cpu__cpu_execution_provider_is_available_impl(ptr, rust_vec_len, data_len),
62 => wire__crate__api__execution_providers__cpu__cpu_execution_provider_name_impl(ptr, rust_vec_len, data_len),
63 => wire__crate__api__execution_providers__cpu__cpu_execution_provider_new_impl(ptr, rust_vec_len, data_len),
64 => wire__crate__api__execution_providers__cpu__cpu_execution_provider_supported_by_platform_impl(ptr, rust_vec_len, data_len),
66 => wire__crate__api__execution_providers__cuda__cuda_execution_provider_is_available_impl(ptr, rust_vec_len, data_len),
67 => wire__crate__api__execution_providers__cuda__cuda_execution_provider_name_impl(ptr, rust_vec_len, data_len),
68 => wire__crate__api__execution_providers__cuda__cuda_execution_provider_new_impl(ptr, rust_vec_len, data_len),
69 => wire__crate__api__execution_providers__cuda__cuda_execution_provider_supported_by_platform_impl(ptr, rust_vec_len, data_len),
71 => wire__crate__api__execution_providers__directml__direct_ml_execution_provider_is_available_impl(ptr, rust_vec_len, data_len),
72 => wire__crate__api__execution_providers__directml__direct_ml_execution_provider_name_impl(ptr, rust_vec_len, data_len),
73 => wire__crate__api__execution_providers__directml__direct_ml_execution_provider_new_impl(ptr, rust_vec_len, data_len),
74 => wire__crate__api__execution_providers__directml__direct_ml_execution_provider_supported_by_platform_impl(ptr, rust_vec_len, data_len),
77 => wire__crate__api__execution_providers__nnapi__nnapi_execution_provider_is_available_impl(ptr, rust_vec_len, data_len),
78 => wire__crate__api__execution_providers__nnapi__nnapi_execution_provider_name_impl(ptr, rust_vec_len, data_len),
79 => wire__crate__api__execution_providers__nnapi__nnapi_execution_provider_new_impl(ptr, rust_vec_len, data_len),
80 => wire__crate__api__execution_providers__nnapi__nnapi_execution_provider_supported_by_platform_impl(ptr, rust_vec_len, data_len),
81 => wire__crate__api__logging__ort_debug_messages_impl(ptr, rust_vec_len, data_len),
83 => wire__crate__api__execution_providers__qnn__qnn_execution_provider_is_available_impl(ptr, rust_vec_len, data_len),
84 => wire__crate__api__execution_providers__qnn__qnn_execution_provider_name_impl(ptr, rust_vec_len, data_len),
85 => wire__crate__api__execution_providers__qnn__qnn_execution_provider_new_impl(ptr, rust_vec_len, data_len),
86 => wire__crate__api__execution_providers__qnn__qnn_execution_provider_supported_by_platform_impl(ptr, rust_vec_len, data_len),
88 => wire__crate__api__execution_providers__rocm__ro_cm_execution_provider_is_available_impl(ptr, rust_vec_len, data_len),
89 => wire__crate__api__execution_providers__rocm__ro_cm_execution_provider_name_impl(ptr, rust_vec_len, data_len),
90 => wire__crate__api__execution_providers__rocm__ro_cm_execution_provider_new_impl(ptr, rust_vec_len, data_len),
91 => wire__crate__api__execution_providers__rocm__ro_cm_execution_provider_supported_by_platform_impl(ptr, rust_vec_len, data_len),
96 => wire__crate__api__execution_providers__tensorrt__tensor_rt_execution_provider_is_available_impl(ptr, rust_vec_len, data_len),
97 => wire__crate__api__execution_providers__tensorrt__tensor_rt_execution_provider_name_impl(ptr, rust_vec_len, data_len),
98 => wire__crate__api__execution_providers__tensorrt__tensor_rt_execution_provider_new_impl(ptr, rust_vec_len, data_len),
99 => wire__crate__api__execution_providers__tensorrt__tensor_rt_execution_provider_supported_by_platform_impl(ptr, rust_vec_len, data_len),
101 => wire__crate__api__execution_providers__xnnpack__xnnpack_execution_provider_is_available_impl(ptr, rust_vec_len, data_len),
102 => wire__crate__api__execution_providers__xnnpack__xnnpack_execution_provider_name_impl(ptr, rust_vec_len, data_len),
103 => wire__crate__api__execution_providers__xnnpack__xnnpack_execution_provider_new_impl(ptr, rust_vec_len, data_len),
104 => wire__crate__api__execution_providers__xnnpack__xnnpack_execution_provider_supported_by_platform_impl(ptr, rust_vec_len, data_len),
                        _ => unreachable!(),
                    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<MemoryInfo> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<MemoryInfo> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<MemoryInfo>> for MemoryInfo {
    fn into_into_dart(self) -> FrbWrapper<MemoryInfo> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<SessionImpl> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<SessionImpl> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<SessionImpl>> for SessionImpl {
    fn into_into_dart(self) -> FrbWrapper<SessionImpl> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<TensorImpl> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<TensorImpl> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<TensorImpl>> for TensorImpl {
    fn into_into_dart(self) -> FrbWrapper<TensorImpl> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::memory::AllocationDevice {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::memory::AllocationDevice::Cpu => [0.into_dart()].into_dart(),
            crate::api::memory::AllocationDevice::Cuda => [1.into_dart()].into_dart(),
            crate::api::memory::AllocationDevice::CudaPinned => [2.into_dart()].into_dart(),
            crate::api::memory::AllocationDevice::Cann => [3.into_dart()].into_dart(),
            crate::api::memory::AllocationDevice::CannPinned => [4.into_dart()].into_dart(),
            crate::api::memory::AllocationDevice::DirectML => [5.into_dart()].into_dart(),
            crate::api::memory::AllocationDevice::Hip => [6.into_dart()].into_dart(),
            crate::api::memory::AllocationDevice::HipPinned => [7.into_dart()].into_dart(),
            crate::api::memory::AllocationDevice::OpenVinoCpu => [8.into_dart()].into_dart(),
            crate::api::memory::AllocationDevice::OpenVinoGpu => [9.into_dart()].into_dart(),
            crate::api::memory::AllocationDevice::QnnHtpShared => [10.into_dart()].into_dart(),
            crate::api::memory::AllocationDevice::WebGpuBuffer => [11.into_dart()].into_dart(),
            crate::api::memory::AllocationDevice::Other(field0) => {
                [12.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::memory::AllocationDevice
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::memory::AllocationDevice>
    for crate::api::memory::AllocationDevice
{
    fn into_into_dart(self) -> crate::api::memory::AllocationDevice {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::memory::AllocatorType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::memory::AllocatorType::Device => 0.into_dart(),
            crate::api::memory::AllocatorType::Arena => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::memory::AllocatorType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::memory::AllocatorType>>
    for crate::api::memory::AllocatorType
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::memory::AllocatorType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::execution_providers::ArenaExtendStrategy>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::execution_providers::ArenaExtendStrategy::NextPowerOfTwo => 0.into_dart(),
            crate::api::execution_providers::ArenaExtendStrategy::SameAsRequested => 1.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::execution_providers::ArenaExtendStrategy>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::execution_providers::ArenaExtendStrategy>,
    > for crate::api::execution_providers::ArenaExtendStrategy
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::execution_providers::ArenaExtendStrategy> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::tensor::ArrayPointer {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.ptr.into_into_dart().into_dart(),
            self.len.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::tensor::ArrayPointer
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::tensor::ArrayPointer>
    for crate::api::tensor::ArrayPointer
{
    fn into_into_dart(self) -> crate::api::tensor::ArrayPointer {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::execution_providers::coreml::CoreMLComputeUnits>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::execution_providers::coreml::CoreMLComputeUnits::All => 0.into_dart(),
            crate::api::execution_providers::coreml::CoreMLComputeUnits::CPUAndNeuralEngine => {
                1.into_dart()
            }
            crate::api::execution_providers::coreml::CoreMLComputeUnits::CPUAndGPU => 2.into_dart(),
            crate::api::execution_providers::coreml::CoreMLComputeUnits::CPUOnly => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::execution_providers::coreml::CoreMLComputeUnits>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::execution_providers::coreml::CoreMLComputeUnits>,
    > for crate::api::execution_providers::coreml::CoreMLComputeUnits
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::api::execution_providers::coreml::CoreMLComputeUnits> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::execution_providers::coreml::CoreMLExecutionProvider
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.subgraphs.into_into_dart().into_dart(),
            self.static_input_shapes.into_into_dart().into_dart(),
            self.model_format.into_into_dart().into_dart(),
            self.specialization_strategy.into_into_dart().into_dart(),
            self.compute_units.into_into_dart().into_dart(),
            self.profile_compute_plan.into_into_dart().into_dart(),
            self.low_precision_accumulation_on_gpu
                .into_into_dart()
                .into_dart(),
            self.model_cache_dir.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::execution_providers::coreml::CoreMLExecutionProvider
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::execution_providers::coreml::CoreMLExecutionProvider,
    > for crate::api::execution_providers::coreml::CoreMLExecutionProvider
{
    fn into_into_dart(self) -> crate::api::execution_providers::coreml::CoreMLExecutionProvider {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::execution_providers::coreml::CoreMLModelFormat>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::execution_providers::coreml::CoreMLModelFormat::MLProgram => 0.into_dart(),
            crate::api::execution_providers::coreml::CoreMLModelFormat::NeuralNetwork => {
                1.into_dart()
            }
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::execution_providers::coreml::CoreMLModelFormat>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::execution_providers::coreml::CoreMLModelFormat>,
    > for crate::api::execution_providers::coreml::CoreMLModelFormat
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::api::execution_providers::coreml::CoreMLModelFormat> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::execution_providers::coreml::CoreMLSpecializationStrategy>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
                    crate::api::execution_providers::coreml::CoreMLSpecializationStrategy::Default => 0.into_dart(),
crate::api::execution_providers::coreml::CoreMLSpecializationStrategy::FastPrediction => 1.into_dart(),
                    _ => unreachable!(),
                }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::execution_providers::coreml::CoreMLSpecializationStrategy>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::execution_providers::coreml::CoreMLSpecializationStrategy>,
    > for crate::api::execution_providers::coreml::CoreMLSpecializationStrategy
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::api::execution_providers::coreml::CoreMLSpecializationStrategy> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::execution_providers::cpu::CPUExecutionProvider {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        Vec::<u8>::new().into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::execution_providers::cpu::CPUExecutionProvider
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::execution_providers::cpu::CPUExecutionProvider>
    for crate::api::execution_providers::cpu::CPUExecutionProvider
{
    fn into_into_dart(self) -> crate::api::execution_providers::cpu::CPUExecutionProvider {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch::Exhaustive => {
                0.into_dart()
            }
            crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch::Heuristic => {
                1.into_dart()
            }
            crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch::Default => {
                2.into_dart()
            }
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch>,
    > for crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::execution_providers::cuda::CUDAAttentionBackend {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::FlashAttention => 0.into_dart(),
            Self::EfficientAttention => 1.into_dart(),
            Self::TrtFusedAttention => 2.into_dart(),
            Self::CudnnFlashAttention => 3.into_dart(),
            Self::Math => 4.into_dart(),
            Self::TrtFlashAttention => 5.into_dart(),
            Self::TrtCrossAttention => 6.into_dart(),
            Self::TrtCausalAttention => 7.into_dart(),
            Self::LeanAttention => 8.into_dart(),
            Self::None => 9.into_dart(),
            Self::All => 10.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::execution_providers::cuda::CUDAAttentionBackend
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::execution_providers::cuda::CUDAAttentionBackend>
    for crate::api::execution_providers::cuda::CUDAAttentionBackend
{
    fn into_into_dart(self) -> crate::api::execution_providers::cuda::CUDAAttentionBackend {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::execution_providers::cuda::CUDAExecutionProvider
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.memory_limit.into_into_dart().into_dart(),
            self.arena_extend_strategy.into_into_dart().into_dart(),
            self.conv_algorithm_search.into_into_dart().into_dart(),
            self.conv_max_workspace.into_into_dart().into_dart(),
            self.conv1d_pad_to_nc1d.into_into_dart().into_dart(),
            self.cuda_graph.into_into_dart().into_dart(),
            self.skip_layer_norm_strict_mode
                .into_into_dart()
                .into_dart(),
            self.tf32.into_into_dart().into_dart(),
            self.prefer_nhwc.into_into_dart().into_dart(),
            self.attention_backend.into_into_dart().into_dart(),
            self.fuse_conv_bias.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::execution_providers::cuda::CUDAExecutionProvider
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::execution_providers::cuda::CUDAExecutionProvider>
    for crate::api::execution_providers::cuda::CUDAExecutionProvider
{
    fn into_into_dart(self) -> crate::api::execution_providers::cuda::CUDAExecutionProvider {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::memory::DeviceType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::memory::DeviceType::CPU => 0.into_dart(),
            crate::api::memory::DeviceType::GPU => 1.into_dart(),
            crate::api::memory::DeviceType::FPGA => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::memory::DeviceType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::memory::DeviceType>>
    for crate::api::memory::DeviceType
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::memory::DeviceType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::execution_providers::directml::DirectMLExecutionProvider
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.device_id.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::execution_providers::directml::DirectMLExecutionProvider
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::execution_providers::directml::DirectMLExecutionProvider,
    > for crate::api::execution_providers::directml::DirectMLExecutionProvider
{
    fn into_into_dart(
        self,
    ) -> crate::api::execution_providers::directml::DirectMLExecutionProvider {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::execution_providers::ExecutionProvider {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::api::execution_providers::ExecutionProvider::CoreML(field0) => {
                [0.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::execution_providers::ExecutionProvider::CPU(field0) => {
                [1.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::execution_providers::ExecutionProvider::CUDA(field0) => {
                [2.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::execution_providers::ExecutionProvider::DirectML(field0) => {
                [3.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::execution_providers::ExecutionProvider::NNApi(field0) => {
                [4.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::execution_providers::ExecutionProvider::QNN(field0) => {
                [5.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::execution_providers::ExecutionProvider::ROCm(field0) => {
                [6.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::execution_providers::ExecutionProvider::TensorRT(field0) => {
                [7.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            crate::api::execution_providers::ExecutionProvider::XNNPACK(field0) => {
                [8.into_dart(), field0.into_into_dart().into_dart()].into_dart()
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::execution_providers::ExecutionProvider
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::execution_providers::ExecutionProvider>
    for crate::api::execution_providers::ExecutionProvider
{
    fn into_into_dart(self) -> crate::api::execution_providers::ExecutionProvider {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::session::builder::impl_options::GraphOptimizationLevel>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::session::builder::impl_options::GraphOptimizationLevel::Disable => {
                0.into_dart()
            }
            crate::api::session::builder::impl_options::GraphOptimizationLevel::Level1 => {
                1.into_dart()
            }
            crate::api::session::builder::impl_options::GraphOptimizationLevel::Level2 => {
                2.into_dart()
            }
            crate::api::session::builder::impl_options::GraphOptimizationLevel::Level3 => {
                3.into_dart()
            }
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::session::builder::impl_options::GraphOptimizationLevel>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::session::builder::impl_options::GraphOptimizationLevel>,
    > for crate::api::session::builder::impl_options::GraphOptimizationLevel
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::api::session::builder::impl_options::GraphOptimizationLevel> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::session::Input {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.name.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::session::Input {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::session::Input> for crate::api::session::Input {
    fn into_into_dart(self) -> crate::api::session::Input {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::memory::MemoryType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::memory::MemoryType::CPUInput => 0.into_dart(),
            crate::api::memory::MemoryType::CPUOutput => 1.into_dart(),
            crate::api::memory::MemoryType::Default => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::memory::MemoryType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::memory::MemoryType>>
    for crate::api::memory::MemoryType
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::memory::MemoryType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::execution_providers::nnapi::NNAPIExecutionProvider
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.fp16.into_into_dart().into_dart(),
            self.nchw.into_into_dart().into_dart(),
            self.disable_cpu.into_into_dart().into_dart(),
            self.cpu_only.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::execution_providers::nnapi::NNAPIExecutionProvider
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::execution_providers::nnapi::NNAPIExecutionProvider,
    > for crate::api::execution_providers::nnapi::NNAPIExecutionProvider
{
    fn into_into_dart(self) -> crate::api::execution_providers::nnapi::NNAPIExecutionProvider {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::logging::OrtDebugLevel {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            Self::Trace => 0.into_dart(),
            Self::Debug => 1.into_dart(),
            Self::Info => 2.into_dart(),
            Self::Warn => 3.into_dart(),
            Self::Error => 4.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::logging::OrtDebugLevel
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::logging::OrtDebugLevel>
    for crate::api::logging::OrtDebugLevel
{
    fn into_into_dart(self) -> crate::api::logging::OrtDebugLevel {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::session::Output {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.name.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for crate::api::session::Output {}
impl flutter_rust_bridge::IntoIntoDart<crate::api::session::Output>
    for crate::api::session::Output
{
    fn into_into_dart(self) -> crate::api::session::Output {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::execution_providers::qnn::QNNContextPriority>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::execution_providers::qnn::QNNContextPriority::Low => 0.into_dart(),
            crate::api::execution_providers::qnn::QNNContextPriority::Normal => 1.into_dart(),
            crate::api::execution_providers::qnn::QNNContextPriority::NormalHigh => 2.into_dart(),
            crate::api::execution_providers::qnn::QNNContextPriority::High => 3.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::execution_providers::qnn::QNNContextPriority>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::execution_providers::qnn::QNNContextPriority>,
    > for crate::api::execution_providers::qnn::QNNContextPriority
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::api::execution_providers::qnn::QNNContextPriority> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::execution_providers::qnn::QNNExecutionProvider {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.backend_path.into_into_dart().into_dart(),
            self.profiling.into_into_dart().into_dart(),
            self.profiling_path.into_into_dart().into_dart(),
            self.rpc_control_latency.into_into_dart().into_dart(),
            self.vtcm_mb.into_into_dart().into_dart(),
            self.performance_mode.into_into_dart().into_dart(),
            self.saver_path.into_into_dart().into_dart(),
            self.context_priority.into_into_dart().into_dart(),
            self.htp_graph_finalization_optimization_mode
                .into_into_dart()
                .into_dart(),
            self.soc_model.into_into_dart().into_dart(),
            self.htp_arch.into_into_dart().into_dart(),
            self.device_id.into_into_dart().into_dart(),
            self.htp_fp16_precision.into_into_dart().into_dart(),
            self.offload_graph_io_quantization
                .into_into_dart()
                .into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::execution_providers::qnn::QNNExecutionProvider
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::execution_providers::qnn::QNNExecutionProvider>
    for crate::api::execution_providers::qnn::QNNExecutionProvider
{
    fn into_into_dart(self) -> crate::api::execution_providers::qnn::QNNExecutionProvider {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::execution_providers::qnn::QNNPerformanceMode>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::execution_providers::qnn::QNNPerformanceMode::Default => 0.into_dart(),
            crate::api::execution_providers::qnn::QNNPerformanceMode::Burst => 1.into_dart(),
            crate::api::execution_providers::qnn::QNNPerformanceMode::Balanced => 2.into_dart(),
            crate::api::execution_providers::qnn::QNNPerformanceMode::HighPerformance => {
                3.into_dart()
            }
            crate::api::execution_providers::qnn::QNNPerformanceMode::HighPowerSaver => {
                4.into_dart()
            }
            crate::api::execution_providers::qnn::QNNPerformanceMode::LowPowerSaver => {
                5.into_dart()
            }
            crate::api::execution_providers::qnn::QNNPerformanceMode::LowBalanced => 6.into_dart(),
            crate::api::execution_providers::qnn::QNNPerformanceMode::PowerSaver => 7.into_dart(),
            crate::api::execution_providers::qnn::QNNPerformanceMode::ExtremePowerSaver => {
                8.into_dart()
            }
            crate::api::execution_providers::qnn::QNNPerformanceMode::SustainedHighPerformance => {
                9.into_dart()
            }
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::execution_providers::qnn::QNNPerformanceMode>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::execution_providers::qnn::QNNPerformanceMode>,
    > for crate::api::execution_providers::qnn::QNNPerformanceMode
{
    fn into_into_dart(
        self,
    ) -> FrbWrapper<crate::api::execution_providers::qnn::QNNPerformanceMode> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for FrbWrapper<crate::api::execution_providers::qnn::QNNProfilingLevel>
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::execution_providers::qnn::QNNProfilingLevel::Off => 0.into_dart(),
            crate::api::execution_providers::qnn::QNNProfilingLevel::Basic => 1.into_dart(),
            crate::api::execution_providers::qnn::QNNProfilingLevel::Detailed => 2.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::execution_providers::qnn::QNNProfilingLevel>
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        FrbWrapper<crate::api::execution_providers::qnn::QNNProfilingLevel>,
    > for crate::api::execution_providers::qnn::QNNProfilingLevel
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::execution_providers::qnn::QNNProfilingLevel> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::execution_providers::rocm::ROCmExecutionProvider
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.exhaustive_conv_search.into_into_dart().into_dart(),
            self.conv_use_max_workspace.into_into_dart().into_dart(),
            self.mem_limit.into_into_dart().into_dart(),
            self.arena_extend_strategy.into_into_dart().into_dart(),
            self.copy_in_default_stream.into_into_dart().into_dart(),
            self.hip_graph.into_into_dart().into_dart(),
            self.tunable_op.into_into_dart().into_dart(),
            self.tuning.into_into_dart().into_dart(),
            self.max_tuning_duration.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::execution_providers::rocm::ROCmExecutionProvider
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::execution_providers::rocm::ROCmExecutionProvider>
    for crate::api::execution_providers::rocm::ROCmExecutionProvider
{
    fn into_into_dart(self) -> crate::api::execution_providers::rocm::ROCmExecutionProvider {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::api::session::SessionBuilderOptions {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.execution_providers.into_into_dart().into_dart(),
            self.intra_threads.into_into_dart().into_dart(),
            self.inter_threads.into_into_dart().into_dart(),
            self.parallel_execution.into_into_dart().into_dart(),
            self.optimization_level.into_into_dart().into_dart(),
            self.memory_pattern.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::session::SessionBuilderOptions
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::api::session::SessionBuilderOptions>
    for crate::api::session::SessionBuilderOptions
{
    fn into_into_dart(self) -> crate::api::session::SessionBuilderOptions {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<crate::api::tensor::TensorElementType> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self.0 {
            crate::api::tensor::TensorElementType::Float32 => 0.into_dart(),
            crate::api::tensor::TensorElementType::Uint8 => 1.into_dart(),
            crate::api::tensor::TensorElementType::Int8 => 2.into_dart(),
            crate::api::tensor::TensorElementType::Uint16 => 3.into_dart(),
            crate::api::tensor::TensorElementType::Int16 => 4.into_dart(),
            crate::api::tensor::TensorElementType::Int32 => 5.into_dart(),
            crate::api::tensor::TensorElementType::Int64 => 6.into_dart(),
            crate::api::tensor::TensorElementType::String => 7.into_dart(),
            crate::api::tensor::TensorElementType::Bool => 8.into_dart(),
            crate::api::tensor::TensorElementType::Float16 => 9.into_dart(),
            crate::api::tensor::TensorElementType::Float64 => 10.into_dart(),
            crate::api::tensor::TensorElementType::Uint32 => 11.into_dart(),
            crate::api::tensor::TensorElementType::Uint64 => 12.into_dart(),
            crate::api::tensor::TensorElementType::Bfloat16 => 13.into_dart(),
            crate::api::tensor::TensorElementType::Complex64 => 14.into_dart(),
            crate::api::tensor::TensorElementType::Complex128 => 15.into_dart(),
            crate::api::tensor::TensorElementType::Float8E4M3FN => 16.into_dart(),
            crate::api::tensor::TensorElementType::Float8E4M3FNUZ => 17.into_dart(),
            crate::api::tensor::TensorElementType::Float8E5M2 => 18.into_dart(),
            crate::api::tensor::TensorElementType::Float8E5M2FNUZ => 19.into_dart(),
            crate::api::tensor::TensorElementType::Uint4 => 20.into_dart(),
            crate::api::tensor::TensorElementType::Int4 => 21.into_dart(),
            crate::api::tensor::TensorElementType::Undefined => 22.into_dart(),
            _ => unreachable!(),
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for FrbWrapper<crate::api::tensor::TensorElementType>
{
}
impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<crate::api::tensor::TensorElementType>>
    for crate::api::tensor::TensorElementType
{
    fn into_into_dart(self) -> FrbWrapper<crate::api::tensor::TensorElementType> {
        self.into()
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::execution_providers::tensorrt::TensorRTExecutionProvider
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.device_id.into_into_dart().into_dart(),
            self.max_workspace_size.into_into_dart().into_dart(),
            self.min_subgraph_size.into_into_dart().into_dart(),
            self.max_partition_iterations.into_into_dart().into_dart(),
            self.fp16.into_into_dart().into_dart(),
            self.int8.into_into_dart().into_dart(),
            self.dla.into_into_dart().into_dart(),
            self.dla_core.into_into_dart().into_dart(),
            self.int8_calibration_table_name
                .into_into_dart()
                .into_dart(),
            self.int8_use_native_calibration_table
                .into_into_dart()
                .into_dart(),
            self.engine_cache.into_into_dart().into_dart(),
            self.engine_cache_path.into_into_dart().into_dart(),
            self.dump_subgraphs.into_into_dart().into_dart(),
            self.engine_cache_prefix.into_into_dart().into_dart(),
            self.weight_stripped_engine.into_into_dart().into_dart(),
            self.onnx_model_folder_path.into_into_dart().into_dart(),
            self.engine_decryption.into_into_dart().into_dart(),
            self.engine_decryption_lib_path.into_into_dart().into_dart(),
            self.force_sequential_engine_build
                .into_into_dart()
                .into_dart(),
            self.context_memory_sharing.into_into_dart().into_dart(),
            self.layer_norm_fp32_fallback.into_into_dart().into_dart(),
            self.timing_cache.into_into_dart().into_dart(),
            self.timing_cache_path.into_into_dart().into_dart(),
            self.force_timing_cache.into_into_dart().into_dart(),
            self.detailed_build_log.into_into_dart().into_dart(),
            self.build_heuristics.into_into_dart().into_dart(),
            self.sparsity.into_into_dart().into_dart(),
            self.builder_optimization_level.into_into_dart().into_dart(),
            self.auxiliary_streams.into_into_dart().into_dart(),
            self.tactic_sources.into_into_dart().into_dart(),
            self.extra_plugin_lib_paths.into_into_dart().into_dart(),
            self.profile_min_shapes.into_into_dart().into_dart(),
            self.profile_max_shapes.into_into_dart().into_dart(),
            self.profile_opt_shapes.into_into_dart().into_dart(),
            self.cuda_graph.into_into_dart().into_dart(),
            self.dump_ep_context_model.into_into_dart().into_dart(),
            self.ep_context_file_path.into_into_dart().into_dart(),
            self.ep_context_embed_mode.into_into_dart().into_dart(),
            self.engine_hw_compatible.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::execution_providers::tensorrt::TensorRTExecutionProvider
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::execution_providers::tensorrt::TensorRTExecutionProvider,
    > for crate::api::execution_providers::tensorrt::TensorRTExecutionProvider
{
    fn into_into_dart(
        self,
    ) -> crate::api::execution_providers::tensorrt::TensorRTExecutionProvider {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart
    for crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider
{
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [self.intra_op_num_threads.into_into_dart().into_dart()].into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider
{
}
impl
    flutter_rust_bridge::IntoIntoDart<
        crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider,
    > for crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider
{
    fn into_into_dart(self) -> crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for MemoryInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for SessionImpl {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for TensorImpl {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for std::collections::HashMap<String, TensorImpl> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<(String, TensorImpl)>>::sse_encode(self.into_iter().collect(), serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for crate::api::memory::AllocationDevice {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::memory::AllocationDevice::Cpu => {
                <i32>::sse_encode(0, serializer);
            }
            crate::api::memory::AllocationDevice::Cuda => {
                <i32>::sse_encode(1, serializer);
            }
            crate::api::memory::AllocationDevice::CudaPinned => {
                <i32>::sse_encode(2, serializer);
            }
            crate::api::memory::AllocationDevice::Cann => {
                <i32>::sse_encode(3, serializer);
            }
            crate::api::memory::AllocationDevice::CannPinned => {
                <i32>::sse_encode(4, serializer);
            }
            crate::api::memory::AllocationDevice::DirectML => {
                <i32>::sse_encode(5, serializer);
            }
            crate::api::memory::AllocationDevice::Hip => {
                <i32>::sse_encode(6, serializer);
            }
            crate::api::memory::AllocationDevice::HipPinned => {
                <i32>::sse_encode(7, serializer);
            }
            crate::api::memory::AllocationDevice::OpenVinoCpu => {
                <i32>::sse_encode(8, serializer);
            }
            crate::api::memory::AllocationDevice::OpenVinoGpu => {
                <i32>::sse_encode(9, serializer);
            }
            crate::api::memory::AllocationDevice::QnnHtpShared => {
                <i32>::sse_encode(10, serializer);
            }
            crate::api::memory::AllocationDevice::WebGpuBuffer => {
                <i32>::sse_encode(11, serializer);
            }
            crate::api::memory::AllocationDevice::Other(field0) => {
                <i32>::sse_encode(12, serializer);
                <String>::sse_encode(field0, serializer);
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for crate::api::memory::AllocatorType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::memory::AllocatorType::Device => 0,
                crate::api::memory::AllocatorType::Arena => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::execution_providers::ArenaExtendStrategy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::execution_providers::ArenaExtendStrategy::NextPowerOfTwo => 0,
                crate::api::execution_providers::ArenaExtendStrategy::SameAsRequested => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::tensor::ArrayPointer {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <usize>::sse_encode(self.ptr, serializer);
        <usize>::sse_encode(self.len, serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::api::execution_providers::coreml::CoreMLComputeUnits {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::execution_providers::coreml::CoreMLComputeUnits::All => 0,
                crate::api::execution_providers::coreml::CoreMLComputeUnits::CPUAndNeuralEngine => {
                    1
                }
                crate::api::execution_providers::coreml::CoreMLComputeUnits::CPUAndGPU => 2,
                crate::api::execution_providers::coreml::CoreMLComputeUnits::CPUOnly => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::execution_providers::coreml::CoreMLExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<bool>>::sse_encode(self.subgraphs, serializer);
        <Option<bool>>::sse_encode(self.static_input_shapes, serializer);
        <Option<crate::api::execution_providers::coreml::CoreMLModelFormat>>::sse_encode(
            self.model_format,
            serializer,
        );
        <Option<crate::api::execution_providers::coreml::CoreMLSpecializationStrategy>>::sse_encode(
            self.specialization_strategy,
            serializer,
        );
        <Option<crate::api::execution_providers::coreml::CoreMLComputeUnits>>::sse_encode(
            self.compute_units,
            serializer,
        );
        <Option<bool>>::sse_encode(self.profile_compute_plan, serializer);
        <Option<bool>>::sse_encode(self.low_precision_accumulation_on_gpu, serializer);
        <Option<String>>::sse_encode(self.model_cache_dir, serializer);
    }
}

impl SseEncode for crate::api::execution_providers::coreml::CoreMLModelFormat {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::execution_providers::coreml::CoreMLModelFormat::MLProgram => 0,
                crate::api::execution_providers::coreml::CoreMLModelFormat::NeuralNetwork => 1,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::execution_providers::coreml::CoreMLSpecializationStrategy {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(match self {crate::api::execution_providers::coreml::CoreMLSpecializationStrategy::Default => { 0 }
crate::api::execution_providers::coreml::CoreMLSpecializationStrategy::FastPrediction => { 1 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::execution_providers::cpu::CPUExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch::Exhaustive => 0,
                crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch::Heuristic => 1,
                crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch::Default => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::execution_providers::cuda::CUDAAttentionBackend {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(match self {crate::api::execution_providers::cuda::CUDAAttentionBackend::FlashAttention => { 0 }
crate::api::execution_providers::cuda::CUDAAttentionBackend::EfficientAttention => { 1 }
crate::api::execution_providers::cuda::CUDAAttentionBackend::TrtFusedAttention => { 2 }
crate::api::execution_providers::cuda::CUDAAttentionBackend::CudnnFlashAttention => { 3 }
crate::api::execution_providers::cuda::CUDAAttentionBackend::Math => { 4 }
crate::api::execution_providers::cuda::CUDAAttentionBackend::TrtFlashAttention => { 5 }
crate::api::execution_providers::cuda::CUDAAttentionBackend::TrtCrossAttention => { 6 }
crate::api::execution_providers::cuda::CUDAAttentionBackend::TrtCausalAttention => { 7 }
crate::api::execution_providers::cuda::CUDAAttentionBackend::LeanAttention => { 8 }
crate::api::execution_providers::cuda::CUDAAttentionBackend::None => { 9 }
crate::api::execution_providers::cuda::CUDAAttentionBackend::All => { 10 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::execution_providers::cuda::CUDAExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<i32>>::sse_encode(self.device_id, serializer);
        <Option<usize>>::sse_encode(self.memory_limit, serializer);
        <Option<crate::api::execution_providers::ArenaExtendStrategy>>::sse_encode(
            self.arena_extend_strategy,
            serializer,
        );
        <Option<crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch>>::sse_encode(
            self.conv_algorithm_search,
            serializer,
        );
        <Option<bool>>::sse_encode(self.conv_max_workspace, serializer);
        <Option<bool>>::sse_encode(self.conv1d_pad_to_nc1d, serializer);
        <Option<bool>>::sse_encode(self.cuda_graph, serializer);
        <Option<bool>>::sse_encode(self.skip_layer_norm_strict_mode, serializer);
        <Option<bool>>::sse_encode(self.tf32, serializer);
        <Option<bool>>::sse_encode(self.prefer_nhwc, serializer);
        <Option<crate::api::execution_providers::cuda::CUDAAttentionBackend>>::sse_encode(
            self.attention_backend,
            serializer,
        );
        <Option<bool>>::sse_encode(self.fuse_conv_bias, serializer);
    }
}

impl SseEncode for crate::api::memory::DeviceType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::memory::DeviceType::CPU => 0,
                crate::api::memory::DeviceType::GPU => 1,
                crate::api::memory::DeviceType::FPGA => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::execution_providers::directml::DirectMLExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<i32>>::sse_encode(self.device_id, serializer);
    }
}

impl SseEncode for crate::api::execution_providers::ExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::api::execution_providers::ExecutionProvider::CoreML(field0) => {
                <i32>::sse_encode(0, serializer);
                <crate::api::execution_providers::coreml::CoreMLExecutionProvider>::sse_encode(
                    field0, serializer,
                );
            }
            crate::api::execution_providers::ExecutionProvider::CPU(field0) => {
                <i32>::sse_encode(1, serializer);
                <crate::api::execution_providers::cpu::CPUExecutionProvider>::sse_encode(
                    field0, serializer,
                );
            }
            crate::api::execution_providers::ExecutionProvider::CUDA(field0) => {
                <i32>::sse_encode(2, serializer);
                <crate::api::execution_providers::cuda::CUDAExecutionProvider>::sse_encode(
                    field0, serializer,
                );
            }
            crate::api::execution_providers::ExecutionProvider::DirectML(field0) => {
                <i32>::sse_encode(3, serializer);
                <crate::api::execution_providers::directml::DirectMLExecutionProvider>::sse_encode(
                    field0, serializer,
                );
            }
            crate::api::execution_providers::ExecutionProvider::NNApi(field0) => {
                <i32>::sse_encode(4, serializer);
                <crate::api::execution_providers::nnapi::NNAPIExecutionProvider>::sse_encode(
                    field0, serializer,
                );
            }
            crate::api::execution_providers::ExecutionProvider::QNN(field0) => {
                <i32>::sse_encode(5, serializer);
                <crate::api::execution_providers::qnn::QNNExecutionProvider>::sse_encode(
                    field0, serializer,
                );
            }
            crate::api::execution_providers::ExecutionProvider::ROCm(field0) => {
                <i32>::sse_encode(6, serializer);
                <crate::api::execution_providers::rocm::ROCmExecutionProvider>::sse_encode(
                    field0, serializer,
                );
            }
            crate::api::execution_providers::ExecutionProvider::TensorRT(field0) => {
                <i32>::sse_encode(7, serializer);
                <crate::api::execution_providers::tensorrt::TensorRTExecutionProvider>::sse_encode(
                    field0, serializer,
                );
            }
            crate::api::execution_providers::ExecutionProvider::XNNPACK(field0) => {
                <i32>::sse_encode(8, serializer);
                <crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider>::sse_encode(
                    field0, serializer,
                );
            }
            _ => {
                unimplemented!("");
            }
        }
    }
}

impl SseEncode for f32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for crate::api::session::builder::impl_options::GraphOptimizationLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::session::builder::impl_options::GraphOptimizationLevel::Disable => 0,
                crate::api::session::builder::impl_options::GraphOptimizationLevel::Level1 => 1,
                crate::api::session::builder::impl_options::GraphOptimizationLevel::Level2 => 2,
                crate::api::session::builder::impl_options::GraphOptimizationLevel::Level3 => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for i16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i8(self).unwrap();
    }
}

impl SseEncode for crate::api::session::Input {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
    }
}

impl SseEncode for Vec<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <i64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <bool>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::execution_providers::ExecutionProvider> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::execution_providers::ExecutionProvider>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::session::Input> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::session::Input>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::api::session::Output> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::api::session::Output>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<f32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <f32>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <f64>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<i16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <i16>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <i32>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<i8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <i8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u16> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u16>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u32>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<(String, TensorImpl)> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <(String, TensorImpl)>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for crate::api::memory::MemoryType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::memory::MemoryType::CPUInput => 0,
                crate::api::memory::MemoryType::CPUOutput => 1,
                crate::api::memory::MemoryType::Default => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::execution_providers::nnapi::NNAPIExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<bool>>::sse_encode(self.fp16, serializer);
        <Option<bool>>::sse_encode(self.nchw, serializer);
        <Option<bool>>::sse_encode(self.disable_cpu, serializer);
        <Option<bool>>::sse_encode(self.cpu_only, serializer);
    }
}

impl SseEncode for Option<usize> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <usize>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::execution_providers::ArenaExtendStrategy> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::execution_providers::ArenaExtendStrategy>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::execution_providers::coreml::CoreMLComputeUnits> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::execution_providers::coreml::CoreMLComputeUnits>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::api::execution_providers::coreml::CoreMLModelFormat> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::execution_providers::coreml::CoreMLModelFormat>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::api::execution_providers::coreml::CoreMLSpecializationStrategy> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::execution_providers::coreml::CoreMLSpecializationStrategy>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::execution_providers::cuda::CuDNNConvAlgorithmSearch>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::api::execution_providers::cuda::CUDAAttentionBackend> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::execution_providers::cuda::CUDAAttentionBackend>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::api::session::builder::impl_options::GraphOptimizationLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::session::builder::impl_options::GraphOptimizationLevel>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::logging::OrtDebugLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::logging::OrtDebugLevel>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::api::execution_providers::qnn::QNNContextPriority> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::execution_providers::qnn::QNNContextPriority>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::api::execution_providers::qnn::QNNPerformanceMode> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::execution_providers::qnn::QNNPerformanceMode>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<crate::api::execution_providers::qnn::QNNProfilingLevel> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::api::execution_providers::qnn::QNNProfilingLevel>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for Option<u32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <u8>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<i64>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<i64>>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<Vec<crate::api::execution_providers::ExecutionProvider>> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <Vec<crate::api::execution_providers::ExecutionProvider>>::sse_encode(
                value, serializer,
            );
        }
    }
}

impl SseEncode for crate::api::logging::OrtDebugLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::logging::OrtDebugLevel::Trace => 0,
                crate::api::logging::OrtDebugLevel::Debug => 1,
                crate::api::logging::OrtDebugLevel::Info => 2,
                crate::api::logging::OrtDebugLevel::Warn => 3,
                crate::api::logging::OrtDebugLevel::Error => 4,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::session::Output {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
    }
}

impl SseEncode for crate::api::execution_providers::qnn::QNNContextPriority {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::execution_providers::qnn::QNNContextPriority::Low => 0,
                crate::api::execution_providers::qnn::QNNContextPriority::Normal => 1,
                crate::api::execution_providers::qnn::QNNContextPriority::NormalHigh => 2,
                crate::api::execution_providers::qnn::QNNContextPriority::High => 3,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::execution_providers::qnn::QNNExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<String>>::sse_encode(self.backend_path, serializer);
        <Option<crate::api::execution_providers::qnn::QNNProfilingLevel>>::sse_encode(
            self.profiling,
            serializer,
        );
        <Option<String>>::sse_encode(self.profiling_path, serializer);
        <Option<u32>>::sse_encode(self.rpc_control_latency, serializer);
        <Option<usize>>::sse_encode(self.vtcm_mb, serializer);
        <Option<crate::api::execution_providers::qnn::QNNPerformanceMode>>::sse_encode(
            self.performance_mode,
            serializer,
        );
        <Option<String>>::sse_encode(self.saver_path, serializer);
        <Option<crate::api::execution_providers::qnn::QNNContextPriority>>::sse_encode(
            self.context_priority,
            serializer,
        );
        <Option<u8>>::sse_encode(self.htp_graph_finalization_optimization_mode, serializer);
        <Option<String>>::sse_encode(self.soc_model, serializer);
        <Option<u32>>::sse_encode(self.htp_arch, serializer);
        <Option<i32>>::sse_encode(self.device_id, serializer);
        <Option<bool>>::sse_encode(self.htp_fp16_precision, serializer);
        <Option<bool>>::sse_encode(self.offload_graph_io_quantization, serializer);
    }
}

impl SseEncode for crate::api::execution_providers::qnn::QNNPerformanceMode {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(match self {crate::api::execution_providers::qnn::QNNPerformanceMode::Default => { 0 }
crate::api::execution_providers::qnn::QNNPerformanceMode::Burst => { 1 }
crate::api::execution_providers::qnn::QNNPerformanceMode::Balanced => { 2 }
crate::api::execution_providers::qnn::QNNPerformanceMode::HighPerformance => { 3 }
crate::api::execution_providers::qnn::QNNPerformanceMode::HighPowerSaver => { 4 }
crate::api::execution_providers::qnn::QNNPerformanceMode::LowPowerSaver => { 5 }
crate::api::execution_providers::qnn::QNNPerformanceMode::LowBalanced => { 6 }
crate::api::execution_providers::qnn::QNNPerformanceMode::PowerSaver => { 7 }
crate::api::execution_providers::qnn::QNNPerformanceMode::ExtremePowerSaver => { 8 }
crate::api::execution_providers::qnn::QNNPerformanceMode::SustainedHighPerformance => { 9 }
 _ => { unimplemented!(""); }}, serializer);
    }
}

impl SseEncode for crate::api::execution_providers::qnn::QNNProfilingLevel {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::execution_providers::qnn::QNNProfilingLevel::Off => 0,
                crate::api::execution_providers::qnn::QNNProfilingLevel::Basic => 1,
                crate::api::execution_providers::qnn::QNNProfilingLevel::Detailed => 2,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for (String, TensorImpl) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.0, serializer);
        <TensorImpl>::sse_encode(self.1, serializer);
    }
}

impl SseEncode for crate::api::execution_providers::rocm::ROCmExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<i32>>::sse_encode(self.device_id, serializer);
        <Option<bool>>::sse_encode(self.exhaustive_conv_search, serializer);
        <Option<bool>>::sse_encode(self.conv_use_max_workspace, serializer);
        <Option<usize>>::sse_encode(self.mem_limit, serializer);
        <Option<crate::api::execution_providers::ArenaExtendStrategy>>::sse_encode(
            self.arena_extend_strategy,
            serializer,
        );
        <Option<bool>>::sse_encode(self.copy_in_default_stream, serializer);
        <Option<bool>>::sse_encode(self.hip_graph, serializer);
        <Option<bool>>::sse_encode(self.tunable_op, serializer);
        <Option<bool>>::sse_encode(self.tuning, serializer);
        <Option<i32>>::sse_encode(self.max_tuning_duration, serializer);
    }
}

impl SseEncode for crate::api::session::SessionBuilderOptions {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<Vec<crate::api::execution_providers::ExecutionProvider>>>::sse_encode(
            self.execution_providers,
            serializer,
        );
        <Option<usize>>::sse_encode(self.intra_threads, serializer);
        <Option<usize>>::sse_encode(self.inter_threads, serializer);
        <Option<bool>>::sse_encode(self.parallel_execution, serializer);
        <Option<crate::api::session::builder::impl_options::GraphOptimizationLevel>>::sse_encode(
            self.optimization_level,
            serializer,
        );
        <Option<bool>>::sse_encode(self.memory_pattern, serializer);
    }
}

impl SseEncode for crate::api::tensor::TensorElementType {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(
            match self {
                crate::api::tensor::TensorElementType::Float32 => 0,
                crate::api::tensor::TensorElementType::Uint8 => 1,
                crate::api::tensor::TensorElementType::Int8 => 2,
                crate::api::tensor::TensorElementType::Uint16 => 3,
                crate::api::tensor::TensorElementType::Int16 => 4,
                crate::api::tensor::TensorElementType::Int32 => 5,
                crate::api::tensor::TensorElementType::Int64 => 6,
                crate::api::tensor::TensorElementType::String => 7,
                crate::api::tensor::TensorElementType::Bool => 8,
                crate::api::tensor::TensorElementType::Float16 => 9,
                crate::api::tensor::TensorElementType::Float64 => 10,
                crate::api::tensor::TensorElementType::Uint32 => 11,
                crate::api::tensor::TensorElementType::Uint64 => 12,
                crate::api::tensor::TensorElementType::Bfloat16 => 13,
                crate::api::tensor::TensorElementType::Complex64 => 14,
                crate::api::tensor::TensorElementType::Complex128 => 15,
                crate::api::tensor::TensorElementType::Float8E4M3FN => 16,
                crate::api::tensor::TensorElementType::Float8E4M3FNUZ => 17,
                crate::api::tensor::TensorElementType::Float8E5M2 => 18,
                crate::api::tensor::TensorElementType::Float8E5M2FNUZ => 19,
                crate::api::tensor::TensorElementType::Uint4 => 20,
                crate::api::tensor::TensorElementType::Int4 => 21,
                crate::api::tensor::TensorElementType::Undefined => 22,
                _ => {
                    unimplemented!("");
                }
            },
            serializer,
        );
    }
}

impl SseEncode for crate::api::execution_providers::tensorrt::TensorRTExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<i32>>::sse_encode(self.device_id, serializer);
        <Option<usize>>::sse_encode(self.max_workspace_size, serializer);
        <Option<usize>>::sse_encode(self.min_subgraph_size, serializer);
        <Option<u32>>::sse_encode(self.max_partition_iterations, serializer);
        <Option<bool>>::sse_encode(self.fp16, serializer);
        <Option<bool>>::sse_encode(self.int8, serializer);
        <Option<bool>>::sse_encode(self.dla, serializer);
        <Option<u32>>::sse_encode(self.dla_core, serializer);
        <Option<String>>::sse_encode(self.int8_calibration_table_name, serializer);
        <Option<bool>>::sse_encode(self.int8_use_native_calibration_table, serializer);
        <Option<bool>>::sse_encode(self.engine_cache, serializer);
        <Option<String>>::sse_encode(self.engine_cache_path, serializer);
        <Option<bool>>::sse_encode(self.dump_subgraphs, serializer);
        <Option<String>>::sse_encode(self.engine_cache_prefix, serializer);
        <Option<bool>>::sse_encode(self.weight_stripped_engine, serializer);
        <Option<String>>::sse_encode(self.onnx_model_folder_path, serializer);
        <Option<bool>>::sse_encode(self.engine_decryption, serializer);
        <Option<String>>::sse_encode(self.engine_decryption_lib_path, serializer);
        <Option<bool>>::sse_encode(self.force_sequential_engine_build, serializer);
        <Option<bool>>::sse_encode(self.context_memory_sharing, serializer);
        <Option<bool>>::sse_encode(self.layer_norm_fp32_fallback, serializer);
        <Option<bool>>::sse_encode(self.timing_cache, serializer);
        <Option<String>>::sse_encode(self.timing_cache_path, serializer);
        <Option<bool>>::sse_encode(self.force_timing_cache, serializer);
        <Option<bool>>::sse_encode(self.detailed_build_log, serializer);
        <Option<bool>>::sse_encode(self.build_heuristics, serializer);
        <Option<bool>>::sse_encode(self.sparsity, serializer);
        <Option<u8>>::sse_encode(self.builder_optimization_level, serializer);
        <Option<i8>>::sse_encode(self.auxiliary_streams, serializer);
        <Option<String>>::sse_encode(self.tactic_sources, serializer);
        <Option<String>>::sse_encode(self.extra_plugin_lib_paths, serializer);
        <Option<String>>::sse_encode(self.profile_min_shapes, serializer);
        <Option<String>>::sse_encode(self.profile_max_shapes, serializer);
        <Option<String>>::sse_encode(self.profile_opt_shapes, serializer);
        <Option<bool>>::sse_encode(self.cuda_graph, serializer);
        <Option<bool>>::sse_encode(self.dump_ep_context_model, serializer);
        <Option<String>>::sse_encode(self.ep_context_file_path, serializer);
        <Option<u8>>::sse_encode(self.ep_context_embed_mode, serializer);
        <Option<bool>>::sse_encode(self.engine_hw_compatible, serializer);
    }
}

impl SseEncode for u16 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u16::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer
            .cursor
            .write_u64::<NativeEndian>(self as _)
            .unwrap();
    }
}

impl SseEncode for crate::api::execution_providers::xnnpack::XNNPACKExecutionProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Option<usize>>::sse_encode(self.intra_op_num_threads, serializer);
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::api::execution_providers::ExecutionProviderBase;
    use crate::api::memory::*;
    use crate::api::session::*;
    use crate::api::tensor::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ort_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryInfo(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ort_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryInfo(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ort_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionImpl(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ort_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionImpl(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ort_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTensorImpl(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_ort_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTensorImpl(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::api::execution_providers::ExecutionProviderBase;
    use crate::api::memory::*;
    use crate::api::session::*;
    use crate::api::tensor::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryInfo(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMemoryInfo(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<MemoryInfo>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionImpl(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionImpl(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTensorImpl(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTensorImpl(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
