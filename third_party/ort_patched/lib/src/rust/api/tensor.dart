// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'memory.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `create_tensor`, `from_value_ref`, `parse_shape`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `eq`, `fmt`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<TensorImpl>>
abstract class TensorImpl implements RustOpaqueInterface {
  /// Creates a copy of this tensor and its data on the same device it resides on.
  TensorImpl clone();

  /// Get the data type of the Tensor
  TensorElementType dtype();

  static void freeBoolPointer({required ArrayPointer arr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeBoolPointer(arr: arr);

  static void freeF32Pointer({required ArrayPointer arr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeF32Pointer(arr: arr);

  static void freeF64Pointer({required ArrayPointer arr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeF64Pointer(arr: arr);

  static void freeI16Pointer({required ArrayPointer arr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeI16Pointer(arr: arr);

  static void freeI32Pointer({required ArrayPointer arr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeI32Pointer(arr: arr);

  static void freeI64Pointer({required ArrayPointer arr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeI64Pointer(arr: arr);

  static void freeI8Pointer({required ArrayPointer arr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeI8Pointer(arr: arr);

  static void freeStringPointer({required ArrayPointer arr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeStringPointer(arr: arr);

  static void freeU16Pointer({required ArrayPointer arr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeU16Pointer(arr: arr);

  static void freeU32Pointer({required ArrayPointer arr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeU32Pointer(arr: arr);

  static void freeU64Pointer({required ArrayPointer arr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeU64Pointer(arr: arr);

  static void freeU8Pointer({required ArrayPointer arr}) =>
      RustLib.instance.api.crateApiTensorTensorImplFreeU8Pointer(arr: arr);

  static TensorImpl fromArrayBool({
    List<int>? shape,
    required List<bool> data,
  }) => RustLib.instance.api.crateApiTensorTensorImplFromArrayBool(
    shape: shape,
    data: data,
  );

  static TensorImpl fromArrayF32({
    List<int>? shape,
    required List<double> data,
  }) => RustLib.instance.api.crateApiTensorTensorImplFromArrayF32(
    shape: shape,
    data: data,
  );

  static TensorImpl fromArrayF64({
    List<int>? shape,
    required List<double> data,
  }) => RustLib.instance.api.crateApiTensorTensorImplFromArrayF64(
    shape: shape,
    data: data,
  );

  static TensorImpl fromArrayI16({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayI16(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayI32({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayI32(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayI64({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayI64(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayI8({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayI8(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayString({
    List<int>? shape,
    required List<String> data,
  }) => RustLib.instance.api.crateApiTensorTensorImplFromArrayString(
    shape: shape,
    data: data,
  );

  static TensorImpl fromArrayU16({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayU16(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayU32({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayU32(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayU64({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayU64(
        shape: shape,
        data: data,
      );

  static TensorImpl fromArrayU8({List<int>? shape, required List<int> data}) =>
      RustLib.instance.api.crateApiTensorTensorImplFromArrayU8(
        shape: shape,
        data: data,
      );

  ArrayPointer getDataBoolPointer();

  ArrayPointer getDataF32Pointer();

  ArrayPointer getDataF64Pointer();

  ArrayPointer getDataI16Pointer();

  ArrayPointer getDataI32Pointer();

  ArrayPointer getDataI64Pointer();

  ArrayPointer getDataI8Pointer();

  ArrayPointer getDataStringPointer();

  ArrayPointer getDataU16Pointer();

  ArrayPointer getDataU32Pointer();

  ArrayPointer getDataU64Pointer();

  ArrayPointer getDataU8Pointer();

  /// If this Tensor's underlying data is mutable
  bool isMutable();

  MemoryInfo memoryInfo();

  /// Get the shape of the Tensor
  List<int> shape();
}

class ArrayPointer {
  final int ptr;
  final int len;

  const ArrayPointer({required this.ptr, required this.len});

  @override
  int get hashCode => ptr.hashCode ^ len.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ArrayPointer &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr &&
          len == other.len;
}

/// Enum mapping ONNX Runtime's supported tensor data types.
enum TensorElementType {
  /// 32-bit floating point number, equivalent to Rust's `f32`.
  float32,

  /// Unsigned 8-bit integer, equivalent to Rust's `u8`.
  uint8,

  /// Signed 8-bit integer, equivalent to Rust's `i8`.
  int8,

  /// Unsigned 16-bit integer, equivalent to Rust's `u16`.
  uint16,

  /// Signed 16-bit integer, equivalent to Rust's `i16`.
  int16,

  /// Signed 32-bit integer, equivalent to Rust's `i32`.
  int32,

  /// Signed 64-bit integer, equivalent to Rust's `i64`.
  int64,

  /// String, equivalent to Rust's `String`.
  string,

  /// Boolean, equivalent to Rust's `bool`.
  bool,

  /// 16-bit floating point number, equivalent to [`half::f16`] (with the `half` feature).
  float16,

  /// 64-bit floating point number, equivalent to Rust's `f64`. Also known as `double`.
  float64,

  /// Unsigned 32-bit integer, equivalent to Rust's `u32`.
  uint32,

  /// Unsigned 64-bit integer, equivalent to Rust's `u64`.
  uint64,

  /// Brain 16-bit floating point number, equivalent to [`half::bf16`] (with the `half` feature).
  bfloat16,
  complex64,
  complex128,

  /// 8-bit floating point number with 4 exponent bits and 3 mantissa bits, with only NaN values and no infinite
  /// values.
  float8E4M3Fn,

  /// 8-bit floating point number with 4 exponent bits and 3 mantissa bits, with only NaN values, no infinite
  /// values, and no negative zero.
  float8E4M3Fnuz,

  /// 8-bit floating point number with 5 exponent bits and 2 mantissa bits.
  float8E5M2,

  /// 8-bit floating point number with 5 exponent bits and 2 mantissa bits, with only NaN values, no infinite
  /// values, and no negative zero.
  float8E5M2Fnuz,

  /// 4-bit unsigned integer.
  uint4,

  /// 4-bit signed integer.
  int4,
  undefined,
}
