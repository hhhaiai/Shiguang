// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'xnnpack.freezed.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `build`

/// [XNNPACK execution provider](https://onnxruntime.ai/docs/execution-providers/Xnnpack-ExecutionProvider.html) for
/// ARM, x86, and WASM platforms.
///
/// # Threading
/// XNNPACK uses its own threadpool separate from the [`Session`](crate::session::Session)'s intra-op threadpool. If
/// most of your model's compute lies in nodes supported by XNNPACK (i.e. `Conv`, `Gemm`, `MatMul`), it's best to
/// disable the session intra-op threadpool to reduce contention:
/// ```no_run
/// # use core::num::NonZeroUsize;
/// # use ort::{execution_providers::xnnpack::XNNPACKExecutionProvider, session::Session};
/// # fn main() -> ort::Result<()> {
/// let session = Session::builder()?
/// 	.with_intra_op_spinning(false)?
/// 	.with_intra_threads(1)?
/// 	.with_execution_providers([XNNPACKExecutionProvider::default()
/// 		.with_intra_op_num_threads(NonZeroUsize::new(4).unwrap())
/// 		.build()])?
/// 	.commit_from_file("model.onnx")?;
/// # Ok(())
/// # }
/// ```
@freezed
sealed class XNNPACKExecutionProvider with _$XNNPACKExecutionProvider {
  const XNNPACKExecutionProvider._();
  const factory XNNPACKExecutionProvider.raw({int? intraOpNumThreads}) =
      _XNNPACKExecutionProvider;
  static Future<XNNPACKExecutionProvider> default_() => RustLib.instance.api
      .crateApiExecutionProvidersXnnpackXnnpackExecutionProviderDefault();

  bool isAvailable() => RustLib.instance.api
      .crateApiExecutionProvidersXnnpackXnnpackExecutionProviderIsAvailable(
        that: this,
      );

  String name() => RustLib.instance.api
      .crateApiExecutionProvidersXnnpackXnnpackExecutionProviderName(
        that: this,
      );

  factory XNNPACKExecutionProvider() => RustLib.instance.api
      .crateApiExecutionProvidersXnnpackXnnpackExecutionProviderNew();

  bool supportedByPlatform() => RustLib.instance.api
      .crateApiExecutionProvidersXnnpackXnnpackExecutionProviderSupportedByPlatform(
        that: this,
      );
}
