// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'execution_providers.dart';
import 'execution_providers/coreml.dart';
import 'execution_providers/cpu.dart';
import 'execution_providers/cuda.dart';
import 'execution_providers/directml.dart';
import 'execution_providers/nnapi.dart';
import 'execution_providers/qnn.dart';
import 'execution_providers/rocm.dart';
import 'execution_providers/tensorrt.dart';
import 'execution_providers/xnnpack.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
import 'session/builder/impl_options.dart';
import 'tensor.dart';
part 'session.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `build_session`, `from_session`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SessionImpl>>
abstract class SessionImpl implements RustOpaqueInterface {
  /// Creates a new [`SessionBuilder`].
  static SessionBuilderOptions builder() =>
      RustLib.instance.api.crateApiSessionSessionImplBuilder();

  /// Information about the graph's inputs.
  List<Input> inputs();

  /// Information about the graph's outputs.
  List<Output> outputs();

  /// Run input data through the ONNX graph, performing inference.
  ///
  /// See [`crate::inputs!`] for a convenient macro which will help you create your session inputs from `ndarray`s or
  /// other data. You can also provide a `Vec`, array, or `HashMap` of [`Value`]s if you create your inputs
  /// dynamically.
  ///
  /// ```
  /// # use std::sync::Arc;
  /// # use ort::{session::{run_options::RunOptions, Session}, tensor::TensorElementType, value::{Value, ValueType, TensorRef}};
  /// # fn main() -> ort::Result<()> {
  /// let mut session = Session::builder()?.commit_from_file("tests/data/upsample.onnx")?;
  /// let input = ndarray::Array4::<f32>::zeros((1, 64, 64, 3));
  /// let outputs = session.run(ort::inputs![TensorRef::from_array_view(&input)?])?;
  /// # 	Ok(())
  /// # }
  /// ```
  Future<Map<String, TensorImpl>> run({
    required Map<String, TensorImpl> inputValues,
  });
}

/// Information about a [`Session`] input.
@freezed
sealed class Input with _$Input {
  const factory Input({required String name}) = _Input;
}

/// Information about a [`Session`] output.
@freezed
sealed class Output with _$Output {
  const factory Output({required String name}) = _Output;
}

@freezed
sealed class SessionBuilderOptions with _$SessionBuilderOptions {
  const SessionBuilderOptions._();
  const factory SessionBuilderOptions({
    List<ExecutionProvider>? executionProviders,
    int? intraThreads,
    int? interThreads,
    bool? parallelExecution,
    GraphOptimizationLevel? optimizationLevel,
    bool? memoryPattern,
  }) = _SessionBuilderOptions;

  /// Loads an ONNX model from a file and builds the session.
  Future<SessionImpl> commitFromFile({required String modelFilepath}) =>
      RustLib.instance.api.crateApiSessionSessionBuilderOptionsCommitFromFile(
        that: this,
        modelFilepath: modelFilepath,
      );

  /// Load an ONNX graph from memory and commit the session.
  Future<SessionImpl> commitFromMemory({required List<int> modelBytes}) =>
      RustLib.instance.api.crateApiSessionSessionBuilderOptionsCommitFromMemory(
        that: this,
        modelBytes: modelBytes,
      );

  static Future<SessionBuilderOptions> default_() =>
      RustLib.instance.api.crateApiSessionSessionBuilderOptionsDefault();
}
