import 'dart:async';

import 'package:flutter/foundation.dart';

import 'local_embedding_inference.dart';

/// Embedding service with local ONNX-first strategy.
class EmbeddingService {
  static const int _embeddingDimensions = 384;
  static const String _requiredModel = 'bge-small-zh-v1.5-ONNX';

  final LocalEmbeddingInference _localInference;

  EmbeddingService({
    String? wsEndpoint,
    bool preferLocal = true,
    bool allowWebSocketFallback = false,
    bool enforceLocalEndpoint = true,
    LocalEmbeddingInference? localInference,
  }) : _localInference = localInference ?? LocalEmbeddingInference();

  /// Generate embedding vector for text.
  Future<Float32List> generateEmbedding(String text) async {
    final normalized = text.trim();
    if (normalized.isEmpty) {
      return Float32List(_embeddingDimensions);
    }

    // Product requirement: embeddings must be generated by local BGE ONNX model.
    try {
      final embedding = await _localInference.generateEmbedding(normalized);
      if (embedding.length != _embeddingDimensions) {
        throw StateError(
          'Invalid embedding dimensions: ${embedding.length} (expected $_embeddingDimensions)',
        );
      }
      if (kDebugMode) {
        debugPrint(
          '[Embedding] Local $_requiredModel success dim=${embedding.length}',
        );
      }
      return embedding;
    } catch (error, stackTrace) {
      if (kDebugMode) {
        debugPrint('[Embedding] Local $_requiredModel failed: $error');
        debugPrint('$stackTrace');
      }
      rethrow;
    }
  }

  Future<List<Float32List>> generateEmbeddings(List<String> texts) async {
    final results = <Float32List>[];
    for (final text in texts) {
      results.add(await generateEmbedding(text));
    }
    return results;
  }

  Future<bool> isServerAvailable() async {
    try {
      await _localInference.ensureInitialized();
      return true;
    } catch (_) {
      return false;
    }
  }

  void dispose() {
    _localInference.dispose();
  }
}
